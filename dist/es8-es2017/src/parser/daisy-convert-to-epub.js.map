{"version":3,"file":"daisy-convert-to-epub.js","sourceRoot":"","sources":["../../../../src/parser/daisy-convert-to-epub.ts"],"names":[],"mappings":";;;AAOA,gCAAgC;AAChC,yBAAyB;AACzB,mCAAmC;AACnC,6BAA6B;AAC7B,yCAAyC;AACzC,+BAA+B;AAC/B,+BAA+B;AAE/B,yDAA2E;AAC3E,+CAA4C;AAC5C,qEAAyD;AACzD,qDAAkD;AAClD,+DAAgD;AAChD,0DAA6E;AAG7E,2DAG6B;AAE7B,MAAM,KAAK,GAAG,MAAM,CAAC,wCAAwC,CAAC,CAAC;AAE/D,SAAS,UAAU,CAAC,MAAc;IAC9B,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAErC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;QACzB,UAAU,CAAC,OAAO,CAAC,CAAC;QACpB,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;KACzB;AACL,CAAC;AAGM,MAAM,2BAA2B,GAAG,KAAK,EAC5C,aAAqB,EACrB,WAAwB,EACxB,8BAAuC,EAA+B,EAAE;IAIxE,OAAO,IAAI,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE;;QAMzC,MAAM,eAAe,GAAG,CAAA,MAAA,WAAW,CAAC,QAAQ,0CAAE,cAAc;YAExD,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,eAAe;gBAC9E,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,eAAe,IAAI,CAC7E,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC;gBAC1D,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,CAC7D,CAAC,CAAC;QAEP,MAAM,WAAW,GAAG,CAAA,MAAA,WAAW,CAAC,QAAQ,0CAAE,cAAc;YAEpD,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,UAAU;gBACzE,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,UAAU,CAAC,CAAC;QAE9E,MAAM,UAAU,GAAG,CAAA,MAAA,WAAW,CAAC,QAAQ,0CAAE,cAAc;YAEnD,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,SAAS;gBACxE,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,SAAS,CAAC,CAAC;QAE7E,IAAI,8BAA8B,EAAE;YAChC,IAAI,UAAU,EAAE;gBACZ,KAAK,CAAC,gEAAgE,EAAE,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,EAAE,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,CAAC,CAAC;gBAC9L,OAAO,MAAM,CAAC,qEAAqE,CAAC,CAAC;aACxF;YACD,IAAI,CAAC,WAAW,IAAI,eAAe,EAAE;gBACjC,KAAK,CAAC,uEAAuE,EAAE,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,EAAE,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,CAAC,CAAC;aACxM;SACJ;QAED,MAAM,WAAW,GAAG,WAAW,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QACxD,IAAI,CAAC,WAAW,EAAE;YACd,KAAK,CAAC,sBAAsB,CAAC,CAAC;YAC9B,OAAO,MAAM,CAAC,sBAAsB,CAAC,CAAC;SACzC;QACD,MAAM,GAAG,GAAG,WAAW,CAAC,KAAa,CAAC;QAEtC,MAAM,WAAW,GAAG,CAAC,MAAM,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;YACxD,OAAO,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;QAEH,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,GAAG,WAAW,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,CAAC;QAE5J,IAAI,CAAC,8BAA8B,EAAE;YACjC,UAAU,CAAC,aAAa,CAAC,CAAC;SAC7B;QAED,IAAI,SAAqC,CAAC;QAC1C,MAAM,OAAO,GAAG,8BAA8B,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,cAAO,EAAE,CAAC;QAC3E,IAAI;YACA,IAAI,CAAC,8BAA8B,EAAE;gBACjC,MAAM,WAAW,GAAG,EAAE,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC;gBACvD,OAAmB,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC;qBAC9C,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;oBACd,KAAK,CAAC,WAAW,CAAC,CAAC;oBACnB,IAAI,SAAS,EAAE;wBACX,YAAY,CAAC,SAAS,CAAC,CAAC;wBACxB,SAAS,GAAG,SAAS,CAAC;wBACtB,OAAO,CAAC,aAAa,CAAC,CAAC;qBAC1B;gBACL,CAAC,CAAC;qBAED,EAAE,CAAC,OAAO,EAAE,CAAC,CAAM,EAAE,EAAE;oBACpB,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;oBACtB,MAAM,CAAC,CAAC,CAAC,CAAC;gBACd,CAAC,CAAC,CAAC;aACV;YAGD,MAAM,MAAM,GAAG,KAAK,CAAC,aAAa,CAAC;gBAC/B,MAAM,EAAE,yCAAyC;aAGpD,CAAC,CAAC;YAsFH,MAAM,YAAY,GAAG;gBACjB,SAAS;gBACT,SAAS;gBACT,YAAY;gBACZ,QAAQ;gBACR,KAAK;gBACL,YAAY;gBACZ,MAAM;gBACN,YAAY;gBACZ,QAAQ;gBACR,SAAS;gBACT,MAAM;gBACN,KAAK;gBACL,UAAU;gBACV,YAAY;gBACZ,UAAU;gBACV,KAAK;gBACL,WAAW;gBACX,UAAU;gBACV,QAAQ;gBACR,UAAU;gBACV,aAAa;gBACb,IAAI;gBACJ,UAAU;gBACV,KAAK;gBACL,OAAO;gBACP,SAAS;gBACT,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,KAAK;gBACL,MAAM;gBACN,WAAW;gBACX,SAAS;gBACT,MAAM;gBACN,MAAM;gBACN,MAAM;gBACN,SAAS;gBACT,SAAS;gBACT,MAAM;gBACN,UAAU;gBACV,YAAY;gBACZ,MAAM;gBACN,MAAM;gBACN,KAAK;gBACL,KAAK;gBACL,GAAG;gBACH,GAAG;gBACH,QAAQ;gBACR,SAAS;gBACT,YAAY;gBACZ,MAAM;gBACN,SAAS;gBACT,OAAO;aACV,CAAC;YAQF,IAAI,gBAAoC,CAAC;YAEzC,MAAM,wBAAwB,GAAG,CAAC,EAAoB,EAAU,EAAE;gBAC9D,IAAI,QAAQ,GAAG,CAAC,CAAC;gBAEjB,IAAI,OAAO,EAAE,CAAC,cAAc,KAAK,WAAW;oBACxC,OAAO,EAAE,CAAC,YAAY,KAAK,WAAW,EAAE;oBAExC,QAAQ,GAAG,EAAE,CAAC,YAAY,GAAG,EAAE,CAAC,cAAc,CAAC;iBAElD;qBAAM,IAAI,EAAE,CAAC,QAAQ,EAAE;oBACpB,KAAK,MAAM,KAAK,IAAI,EAAE,CAAC,QAAQ,EAAE;wBAC7B,QAAQ,IAAI,wBAAwB,CAAC,KAAK,CAAC,CAAC;qBAC/C;iBACJ;gBAED,OAAO,QAAQ,CAAC;YACpB,CAAC,CAAC;YAEF,MAAM,0BAA0B,GAAG,CAC/B,EAAoB,EACpB,qBAAyC,EAAsB,EAAE;gBAEjE,IAAI,WAA+B,CAAC;gBAGpC,IAAI,qBAAqB,IAAI,EAAE,CAAC,KAAK,EAAE;oBACnC,WAAW,GAAG,qBAAqB,CAAC;oBACpC,EAAE,CAAC,IAAI,GAAG,GAAG,WAAW,IAAI,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,MAAM,IAAI,OAAO,EAAE,CAAC;iBAClE;qBAAM,IAAI,EAAE,CAAC,IAAI,EAAE;oBAChB,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,4BAA4B,EAAE,UAAU,CAAC,CAAC;oBACpE,WAAW,GAAG,EAAE,CAAC,IAAI,CAAC;oBACtB,MAAM,CAAC,GAAG,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;oBACnC,IAAI,CAAC,GAAG,CAAC,EAAE;wBACP,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;qBAC1C;iBACJ;gBACD,IAAI,EAAE,CAAC,QAAQ,EAAE;oBACb,KAAK,MAAM,KAAK,IAAI,EAAE,CAAC,QAAQ,EAAE;wBAC7B,MAAM,YAAY,GAAG,0BAA0B,CAAC,KAAK,EAAE,qBAAqB,CAAC,CAAC;wBAC9E,IAAI,CAAC,YAAY,EAAE;4BACf,KAAK,CAAC,wCAAwC,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;yBACxE;6BAAM,IAAI,WAAW,IAAI,WAAW,KAAK,YAAY,EAAE;4BACpD,KAAK,CAAC,wDAAwD,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;yBAC9F;wBACD,IAAI,CAAC,WAAW,EAAE;4BACd,WAAW,GAAG,YAAY,CAAC;yBAC9B;qBACJ;iBACJ;gBAED,OAAO,WAAW,CAAC;YACvB,CAAC,CAAC;YAGF,MAAM,QAAQ,GAA6B,EAAE,CAAC;YAE9C,MAAM,mBAAmB,GAAG,KAAK,EAAE,aAAqB,EAAqB,EAAE;gBAE3E,IAAI,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAC;gBACtC,IAAI,CAAC,OAAO,EAAE;oBACV,IAAI,OAAO,GAAG,SAAS,CAAC;oBACxB,IAAI;wBACA,OAAO,GAAG,MAAM,IAAA,0CAAsB,EAAC,aAAa,EAAE,aAAa,EAAE,GAAG,CAAC,CAAC;qBAC7E;oBAAC,OAAO,MAAM,EAAE;wBACb,KAAK,CAAC,MAAM,CAAC,CAAC;qBACjB;oBACD,IAAI,CAAC,OAAO,EAAE;wBACV,KAAK,CAAC,2BAA2B,EAAE,aAAa,CAAC,CAAC;wBAClD,OAAO,OAAO,CAAC,MAAM,CAAC,4BAA4B,GAAG,aAAa,CAAC,CAAC;qBACvE;oBACD,OAAO,GAAG,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC,eAAe,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;oBAC7E,IAAI,WAAW,EAAE;wBACb,IAAA,6CAAyB,EAAC,aAAa,EAAE,OAAO,CAAC,CAAC;qBACrD;oBACD,QAAQ,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC;iBACrC;gBACD,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACpC,CAAC,CAAC;YAEF,MAAM,aAAa,GAAG,CAAC,KAAa,EAAE,WAAmB,EAAoB,EAAE;gBAC3E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;oBACtB,IAAI,IAAI,CAAC,WAAW,KAAK,WAAW,EAAE;wBAClC,OAAO,IAAI,CAAC;qBACf;yBAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACtB,MAAM,SAAS,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;wBAC5D,IAAI,SAAS,EAAE;4BACX,OAAO,SAAS,CAAC;yBACpB;qBACJ;iBACJ;gBACD,OAAO,SAAS,CAAC;YACrB,CAAC,CAAC;YAEF,MAAM,sBAAsB,GAAG,KAAK,EAAE,aAAqB,EAA+B,EAAE;gBACxF,IAAI,8BAA8B,EAAE;oBAChC,OAAO,SAAS,CAAC;iBACpB;gBAED,IAAI,OAAO,GAAG,SAAS,CAAC;gBACxB,IAAI;oBACA,OAAO,GAAG,MAAM,mBAAmB,CAAC,aAAa,CAAC,CAAC;iBACtD;gBAAC,OAAO,MAAM,EAAE;oBACb,KAAK,CAAC,MAAM,CAAC,CAAC;iBACjB;gBACD,IAAI,CAAC,OAAO,EAAE;oBACV,OAAO,SAAS,CAAC;iBACpB;gBAED,MAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,CAAa,CAAC;gBAEzD,IAAI,UAAU,GAAG,CAAC,CAAC;gBAKnB,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;gBACpE,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;oBAKxB,MAAM,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;oBACzF,KAAK,MAAM,YAAY,IAAI,aAAa,EAAE;wBACtC,IAAI,YAAY,CAAC,UAAU,EAAE;4BACzB,YAAY,CAAC,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;yBACrD;qBACJ;oBAED,IAAI,MAAiC,CAAC;oBACtC,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;oBACvF,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE;wBAIpC,MAAM,GAAG,GAAG,WAAW,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;wBAC5C,IAAI,GAAG,EAAE;4BACL,WAAW,CAAC,YAAY,CAAC,UAAU,EAC/B,GAAG,CAAC,OAAO,CAAC,4BAA4B,EAAE,UAAU,CAAC,CAAC,CAAC;4BAC3D,WAAW,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;yBACtC;wBAED,IAAI,CAAC,MAAM,EAAE;4BACT,MAAM,GAAG,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;yBAC3C;qBAWJ;oBAED,MAAM,KAAK,GAAG,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;oBACvC,MAAM,WAAW,GAAG,GAAG,aAAa,IAAI,KAAK,EAAE,CAAC;oBAChD,IAAI,WAAW,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,aAAa,CAAC,WAAW,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;oBAC5F,IAAI,CAAC,WAAW,IAAI,MAAM,EAAE;wBACxB,MAAM,YAAY,GAAG,GAAG,aAAa,IAAI,MAAM,EAAE,CAAC;wBAClD,WAAW,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,aAAa,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;qBAC5F;oBACD,MAAM,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;oBACzD,IAAI,IAAI,EAAE;wBACN,UAAU,GAAG,CAAC,CAAC;qBAClB;oBACD,MAAM,QAAQ,GAAG,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,UAAU,GAAG,CAAC,CAAC;oBACpF,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;iBAC/B;gBAED,MAAM,WAAW,GAAG,YAAY,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAY,CAAC;gBAC5E,MAAM,cAAc,GAAG,IAAI,MAAM,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;gBACjF,MAAM,UAAU,GAAG,cAAc;qBAC5B,OAAO,CAAC,0CAA0C,EAAE,EAAE,CAAC;qBACvD,OAAO,CAAC,OAAO,EAAE,WAAW,CAAC;qBAC7B,OAAO,CAAC,WAAW,EAAE,eAAe,CAAC;qBACrC,OAAO,CAAC,QAAQ,EAAE,YAAY,CAAC;qBAC/B,OAAO,CAAC,mBAAmB,EAAE,uBAAuB,CAAC;qBACrD,OAAO,CAAC,cAAc,EAAE,kBAAkB,CAAC;qBAC3C,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC;qBACjC,OAAO,CAAC,OAAO,EAAE,yBAAyB,CAAC;qBAC3C,OAAO,CAAC,QAAQ,EAAE,yBAAyB,CAAC;qBAC5C,OAAO,CAAC,OAAO,EAAE,uBAAuB,CAAC;qBACzC,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC;qBAC7B,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAC3B;gBAEL,MAAM,OAAO,GAAG;;;;iBAIf,aAAa;;MAExB,UAAU;;CAEf,CAAC;gBACc,MAAM,YAAY,GAAG,aAAa,CAAC,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;gBAEhE,OAAmB,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,YAAY,CAAC,CAAC;gBAEnE,OAAO,YAAY,CAAC;YACxB,CAAC,CAAC;YAEF,MAAM,kBAAkB,GAAW,EAAE,CAAC;YAEtC,IAAI,WAAW,CAAC,KAAK,EAAE;gBACnB,gBAAgB,GAAG,EAAE,CAAC;gBAEtB,IAAI,gBAAkC,CAAC;gBACvC,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC;gBACpB,KAAK,MAAM,QAAQ,IAAI,WAAW,CAAC,KAAK,EAAE;oBACtC,UAAU,EAAE,CAAC;oBACb,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE;wBACzB,SAAS;qBACZ;oBAED,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,EAAE;wBAErC,MAAM,IAAA,yCAAqB,EAAC,WAAW,EAAE,QAAQ,CAAC,aAAa,CAAC,CAAC;wBAEjE,IAAI,eAAe,IAAI,WAAW,EAAE;4BAChC,IAAA,mCAAe,EAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;yBAC9D;qBACJ;oBAED,IAAI,eAAe,IAAI,WAAW,EAAE;wBAChC,MAAM,WAAW,GAAG,wBAAwB,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;wBACrE,IAAI,WAAW,EAAE;4BACb,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,EAAE;gCAClC,QAAQ,CAAC,aAAa,CAAC,QAAQ,GAAG,WAAW,CAAC;gCAE9C,IAAA,mCAAe,EAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;6BAC1C;iCAAM;gCACH,IAAI,QAAQ,CAAC,aAAa,CAAC,QAAQ,KAAK,WAAW,EAAE;oCACjD,KAAK,CAAC,iDAAiD,EACnD,QAAQ,CAAC,aAAa,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;iCACrD;6BACJ;yBACJ;wBAED,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,aAAa;4BAElD,OAAO,gBAAgB,CAAC,aAAa,CAAC,gBAAgB,KAAK,WAAW;4BACtE,OAAO,QAAQ,CAAC,aAAa,CAAC,gBAAgB,KAAK,WAAW,EAAE;4BAEhE,MAAM,GAAG,GAAG,QAAQ,CAAC,aAAa,CAAC,gBAAgB;gCAC/C,gBAAgB,CAAC,aAAa,CAAC,gBAAgB,CAAC;4BACpD,IAAI,GAAG,GAAG,CAAC,EAAE;gCACT,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,QAAQ,EAAE;oCAC1C,gBAAgB,CAAC,aAAa,CAAC,QAAQ,GAAG,GAAG,CAAC;oCAE9C,IAAA,mCAAe,EAAC,GAAG,EAAE,gBAAgB,CAAC,CAAC;iCAC1C;qCAAM;oCACH,IAAI,gBAAgB,CAAC,aAAa,CAAC,QAAQ,KAAK,GAAG,EAAE;wCACjD,KAAK,CAAC,iDAAiD,EACnD,gBAAgB,CAAC,aAAa,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;qCACrD;iCACJ;6BACJ;yBACJ;wBACD,gBAAgB,GAAG,QAAQ,CAAC;qBAC/B;oBAMD,IAAI,WAA+B,CAAC;oBAEpC,MAAM,YAAY,GAAG,WAAW,IAAI,CAAC,eAAe,IAAI,8BAA8B,CAAC,CAAC;oBAExF,IAAI,YAAY,EAAE;wBACd,MAAM,qBAAqB,GACvB,MAAA,QAAQ,CAAC,aAAa,CAAC,aAAa,0CAAE,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;wBACxE,IAAI,qBAAqB,EAAE;4BACvB,WAAW,GAAG,0BAA0B,CAAC,QAAQ,CAAC,aAAa,EAAE,qBAAqB,CAAC,CAAC;yBAC3F;qBACJ;yBAAM;wBACH,WAAW,GAAG,0BAA0B,CAAC,QAAQ,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;qBAC/E;oBAED,IAAI,WAAW,EAAE;wBACb,IAAI,YAAY,IAAI,QAAQ,CAAC,aAAa,CAAC,aAAa,EAAE;4BACtD,MAAM,sBAAsB,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;4BAEnE,MAAM,QAAQ,GAAG,IAAI,uBAAI,EAAE,CAAC;4BAC5B,QAAQ,CAAC,IAAI,GAAG,WAAW,CAAC;4BAC5B,QAAQ,CAAC,QAAQ,GAAG,uBAAuB,CAAC;4BAC5C,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;yBACrC;wBAGD,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,EAAE;4BAChC,gBAAgB,CAAC,WAAW,CAAC,GAAG;gCAC5B,KAAK,EAAE,UAAU;gCACjB,GAAG,EAAE,EAAE;6BACV,CAAC;yBACL;wBAED,gBAAgB,CAAC,WAAW,CAAC,CAAC,KAAK,GAAG,UAAU,CAAC;wBACjD,gBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;qBAClE;iBACJ;aACJ;YACD,WAAW,CAAC,KAAK,GAAG,EAAE,CAAC;YAEvB,MAAM,eAAe,GAAW,EAAE,CAAC;YAEnC,MAAM,OAAO,GAAW,CAAC,GAAG,kBAAkB,CAAC,CAAC;YAKhD,KAAK,MAAM,OAAO,IAAI,WAAW,CAAC,SAAS,EAAE;gBAEzC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;oBACtB,SAAS;iBACZ;gBACD,IAAI,OAAO,CAAC,QAAQ,KAAK,UAAU,IAAI,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;oBACxE,IAAI,8BAA8B,EAAE;wBAChC,KAAK,CAAC,mDAAmD,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;wBAChF,SAAS;qBACZ;oBAED,IAAI,OAAO,GAAG,SAAS,CAAC;oBACxB,IAAI;wBACA,OAAO,GAAG,MAAM,IAAA,0CAAsB,EAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;qBAClF;oBAAC,OAAO,MAAM,EAAE;wBACb,KAAK,CAAC,MAAM,CAAC,CAAC;qBACjB;oBACD,IAAI,CAAC,OAAO,EAAE;wBACV,KAAK,CAAC,2BAA2B,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;wBACxD,SAAS;qBACZ;oBAGD,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,sBAAsB,EAAE,CAAC,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,EAAE;wBAC/E,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;wBAClD,OAAO,OAAO,MAAM,MAAM,CAAC;oBAC/B,CAAC,CAAC,CAAC;oBAGH,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE;wBAEpC,MAAM,KAAK,GAAG,IAAI,MAAM,CACpB,wBAAwB,WAAW,qBAAqB,EAAE,GAAG,CAAC,CAAC;wBAWnE,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;wBAG/C,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;qBAClD;oBAGD,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,EAAE,CAAC,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,EAAE;wBAClF,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;wBAC3D,OAAO,KAAK,OAAO,IAAI,CAAC;oBAC5B,CAAC,CAAC,CAAC;oBAMF,OAAmB,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;oBAO1E,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAEjC;qBAAM,IAAI,OAAO,CAAC,QAAQ,KAAK,0BAA0B,IAAI,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;oBAC/F,IAAI,WAAW,IAAI,8BAA8B,EAAE;wBAC/C,KAAK,CAAC,kEAAkE,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;wBAC/F,SAAS;qBACZ;oBAED,IAAI,SAAS,GAAG,SAAS,CAAC;oBAC1B,IAAI;wBACA,SAAS,GAAG,MAAM,IAAA,0CAAsB,EAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;qBACpF;oBAAC,OAAO,MAAM,EAAE;wBACb,KAAK,CAAC,MAAM,CAAC,CAAC;qBACjB;oBACD,IAAI,CAAC,SAAS,EAAE;wBACZ,KAAK,CAAC,2BAA2B,EAAE,SAAS,CAAC,CAAC;wBAC9C,SAAS;qBACZ;oBACD,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;oBAC/C,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,SAAS,EAAE,sDAAsD,CAAC,CAAC;oBACjG,MAAM,SAAS,GAAG,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC,eAAe,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;oBAEvF,IAAI,KAAK,GAAG,MAAA,SAAS,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,0CAAE,WAAW,CAAC;oBACvE,IAAI,KAAK,EAAE;wBACP,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;wBACrB,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;4BACf,KAAK,GAAG,IAAI,CAAC;yBAChB;qBACJ;oBAED,MAAM,YAAY,GAAG,SAAS,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;oBAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBAC1C,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACzC,IAAI,CAAC,WAAW,EAAE;4BACd,SAAS;yBACZ;wBACD,MAAM,IAAI,GAAG,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;wBAC9C,IAAI,IAAI,EAAE;4BAGL,WAAmB,CAAC,OAAO,GAAG,IAAI,CAAC;yBAEvC;qBACJ;oBAMD,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE;wBAKpC,MAAM,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;wBACvF,KAAK,MAAM,EAAE,IAAI,GAAG,EAAE;4BAClB,EAAE,CAAC,YAAY,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;4BAC5C,MAAM,GAAG,GAAG,EAAE,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;4BACrC,EAAE,CAAC,YAAY,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,WAAW,KAAK,CAAC,CAAC;4BAGtE,EAAU,CAAC,OAAO;gCACf,CAAC,CAAC,WAAW,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;oCAClC,CAAC,CAAC,WAAW,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;wCAChC,CAAC,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;4CACnC,CAAC,CAAC,WAAW,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;gDAChC,CAAC,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC;oDACzC,CAAC,CAAC,WAAW,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;wDACtC,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;4DACnC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;4BAC5C,IAAI,WAAW,KAAK,SAAS,EAAE;gCAE3B,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;6BAC7C;iCAAM,IAAI,WAAW,KAAK,YAAY,EAAE;gCAErC,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;6BAC9C;iCAAM,IAAI,WAAW,KAAK,MAAM,EAAE;gCAE/B,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;6BACxC;iCAAM,IAAI,WAAW,KAAK,UAAU,EAAE;gCAEnC,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;6BACxC;iCAAM,IAAI,WAAW,KAAK,SAAS,EAAE;gCAElC,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;6BAC3C;yBACJ;qBACJ;oBAGD,MAAM,WAAW,GACb,MAAM,CAAC,2CAA2C,EAAE,SAAS,CAA4B,CAAC;oBAC9F,MAAM,QAAQ,GAAa,EAAE,CAAC;oBAC9B,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;wBAClC,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;4BACvB,SAAS;yBACZ;wBACD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;4BAC5C,SAAS;yBACZ;wBACD,MAAM,KAAK,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC;wBACjE,IAAI,CAAC,KAAK,EAAE;4BACR,SAAS;yBACZ;wBACD,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;wBAC7B,IAAI,IAAI,EAAE;4BACN,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBACvB;qBACJ;oBAED,MAAM,QAAQ,GAAG,MAAM,CAAC,eAAe,EAAE,SAAS,CAAc,CAAC;oBACjE,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;wBAC5B,MAAM,GAAG,GAAG,OAAO,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;wBAC5C,IAAI,GAAG,EAAE;4BACL,OAAO,CAAC,YAAY,CAAC,cAAc,EAAE,GAAG,CAAC,CAAC;yBAC7C;wBACD,OAAO,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;qBACtC;oBAUD,MAAM,cAAc,GAAG,IAAI,MAAM,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC,SAAS,CAAC;yBACzE,OAAO,CAAC,yDAAyD,EAAE,wCAAwC,CAAC;yBAC5G,OAAO,CAAC,0DAA0D,EAAE,GAAG,CAAC;yBACxE,OAAO,CAAC,mBAAmB,EACxB;;OAErB,CAAC;yBACiB,OAAO,CAAC,oBAAoB,EACzB;;;EAG1B,KAAK,CAAC,CAAC,CAAC,UAAU,KAAK,UAAU,CAAC,CAAC,CAAC,EAAE;CACvC,CAAC;yBACuB,OAAO,CAAC,oBAAoB,EACzB;EAC1B,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE;wBACG,OAAO,EAAE,GAAG,IAAI,GAAG,gDAAgD,EAAE,MAAM,CAAC;oBAChF,CAAC,EAAE,EAAE,CAAC;;CAEjC,CAAC,CAAC;oBACiB,MAAM,aAAa,GAAG,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;oBAM3E,OAAmB,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,aAAa,CAAC,CAAC;oBAE3E,MAAM,WAAW,GAAG,IAAA,8BAAe,EAAC,OAAO,CAAC,CAAC;oBAE7C,MAAM,YAAY,GAAG,IAAA,gCAAiB,EAAO,WAAW,EAAE,uBAAI,CAAC,CAAC;oBAChE,YAAY,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC;oBAC3C,YAAY,CAAC,QAAQ,GAAG,uBAAuB,CAAC;oBAEhD,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;iBAE9B;qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;oBAC3C,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;oBACpC,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;oBACpC,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;oBAO1C,MAAM,IAAI,GAAG,8BAA8B,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,IAAA,6CAAyB,EAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;oBAElI,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;wBACtC,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC;qBAC7E;oBAED,IAAI,IAAI,EAAE;wBACL,OAAmB,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;qBAC7D;oBAED,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBAE9B,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;wBACtC,OAAO,CAAC,QAAQ,KAAK,WAAW;wBAChC,OAAO,CAAC,QAAQ,KAAK,uBAAuB,EAAE;wBAE9C,IAAI,OAAO,CAAC,QAAQ,KAAK,WAAW,EAAE;4BAClC,OAAO,CAAC,QAAQ,GAAG,uBAAuB,CAAC;yBAC9C;wBACD,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;qBACzB;iBACJ;aACJ;YAED,IAAI,gBAAgB,EAAE;gBAClB,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;oBAClD,IAAI,CAAC,gBAAgB,EAAE;wBACnB,OAAO;qBACV;oBACD,KAAK,CAAC,eAAe,GAAG,WAAW,CAAC,CAAC;oBACrC,MAAM,GAAG,GAAG,gBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC;oBAC9C,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;wBAClB,KAAK,CAAC,mBAAmB,GAAG,WAAW,CAAC,CAAC;wBACzC,OAAO;qBACV;oBAED,MAAM,mBAAmB,GAAG,IAAI,gCAAgB,EAAE,CAAC;oBACnD,mBAAmB,CAAC,aAAa,GAAG,SAAS,CAAC;oBAC9C,mBAAmB,CAAC,WAAW,GAAG,IAAI,CAAC;oBACvC,mBAAmB,CAAC,IAAI,GAAG,EAAE,CAAC;oBAC9B,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBACzC,mBAAmB,CAAC,QAAQ,GAAG,CAAC,CAAC;oBAEjC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;oBACX,KAAK,MAAM,EAAE,IAAI,GAAG,EAAE;wBAClB,CAAC,EAAE,CAAC;wBACJ,IAAI,EAAE,CAAC,QAAQ,EAAE;4BACb,KAAK,CAAC,gBAAgB,CAAC,KAAK,GAAG,WAAW,CAAC,CAAC;4BAE5C,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE;gCAC/B,mBAAmB,CAAC,QAAQ,GAAG,EAAE,CAAC;6BACrC;4BACD,mBAAmB,CAAC,QAAQ,GAAG,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;4BAEhF,IAAI,EAAE,CAAC,QAAQ,EAAE;gCACb,mBAAmB,CAAC,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC;6BAC/C;yBACJ;qBACJ;oBACD,gBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,GAAG,CAAC,mBAAmB,CAAC,CAAC;gBAC9D,CAAC,CAAC,CAAC;gBAEH,MAAM,qBAAqB,GAAG,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE;oBAC5E,IAAI,CAAC,gBAAgB,EAAE;wBACnB,OAAO,SAAS,CAAC;qBACpB;oBACD,OAAO;wBACH,KAAK,EAAE,gBAAgB,CAAC,WAAW,CAAC,CAAC,KAAK;wBAC1C,EAAE,EAAE,gBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBACxC,WAAW;qBACd,CAAC;gBACN,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;oBAE9B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,EAAE;wBAC7B,OAAO,CAAC,CAAC,CAAC;qBACb;oBAED,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,EAAE;wBAC7B,OAAO,CAAC,CAAC;qBACZ;oBAED,OAAO,CAAC,CAAC;gBACb,CAAC,CAAC,CAAC;gBAEH,KAAK,MAAM,YAAY,IAAI,qBAAqB,EAAE;oBAC9C,IAAI,CAAC,YAAY,EAAE;wBACf,SAAS;qBACZ;oBACD,KAAK,CAAC,eAAe,EAAE,YAAY,CAAC,KAAK,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;oBAErE,MAAM,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE;wBAClC,OAAO,CAAC,CAAC,WAAW,IAAI,YAAY,CAAC,WAAW,CAAC,CAAC;4BAG9C,CAAC,CAAC,WAAW,CAAC,WAAW,EAAE,KAAK,YAAY,CAAC,WAAW,CAAC,WAAW,EAAE;4BACtE,CAAC,CAAC,KAAK,CAAC;oBAChB,CAAC,CAAC,CAAC;oBAEH,IAAI,CAAC,UAAU,EAAE;wBACb,KAAK,CAAC,cAAc,EAAE,YAAY,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;qBACrF;yBAAM,IAAI,UAAU,CAAC,WAAW,IAAI,YAAY,CAAC,WAAW;wBAGzD,UAAU,CAAC,WAAW,CAAC,WAAW,EAAE,KAAK,YAAY,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE;wBAEjF,KAAK,CAAC,iDAAiD,EACnD,UAAU,CAAC,WAAW,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;qBACzD;yBAAM;wBACH,IAAI,eAAe,IAAI,WAAW,EAAE;4BAChC,UAAU,CAAC,aAAa,GAAG,YAAY,CAAC,EAAE,CAAC;4BAE3C,IAAI,YAAY,CAAC,EAAE,CAAC,QAAQ,EAAE;gCAC1B,UAAU,CAAC,QAAQ,GAAG,YAAY,CAAC,EAAE,CAAC,QAAQ,CAAC;6BAClD;4BAED,MAAM,KAAK,GAAG,uBAAuB,YAAY,CAAC,KAAK,OAAO,CAAC;4BAO/D,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;gCACxB,UAAU,CAAC,UAAU,GAAG,IAAI,gCAAU,EAAE,CAAC;6BAC5C;4BACD,UAAU,CAAC,UAAU,CAAC,YAAY,GAAG,KAAK,CAAC;4BAK3C,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;gCACvB,UAAU,CAAC,SAAS,GAAG,EAAE,CAAC;6BAC7B;4BACD,MAAM,MAAM,GAAG,IAAI,uBAAI,EAAE,CAAC;4BAC1B,MAAM,CAAC,IAAI,GAAG,KAAK,CAAC;4BACpB,MAAM,CAAC,QAAQ,GAAG,+BAA+B,CAAC;4BAClD,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC,QAAQ,CAAC;4BACtC,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;4BAElC,IAAI,CAAC,8BAA8B,EAAE;gCACjC,MAAM,SAAS,GAAG,IAAA,8BAAe,EAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gCACnD,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;gCAC9D,OAAmB,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC,CAAC;6BACjE;4BAED,KAAK,CAAC,sBAAsB,EACxB,YAAY,CAAC,KAAK,EAAE,UAAU,CAAC,WAAW,EAAE,UAAU,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;yBAC/E;6BAAM;4BACH,KAAK,CAAC,iCAAiC,EAAE,YAAY,CAAC,KAAK,EAAE,UAAU,CAAC,WAAW,CAAC,CAAC;yBACxF;wBACD,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qBACtC;iBACJ;aACJ;YAED,WAAW,CAAC,SAAS,GAAG,eAAe,CAAC;YAExC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE;gBACvB,WAAW,CAAC,QAAQ,GAAG,IAAI,mBAAQ,EAAE,CAAC;aACzC;YAED,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,EAAE;gBACtC,WAAW,CAAC,QAAQ,CAAC,cAAc,GAAG,EAAE,CAAC;aAC5C;YACD,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,kCAAkC;gBAClE,WAAW,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC;YAE5F,MAAM,8BAA8B,GAAG,CAAC,MAAe,EAAE,KAAc,EAAuB,EAAE;gBAC5F,IAAI,MAAM,CAAC,UAAU,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE;oBAE/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBAC/C,MAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;wBACnC,IAAI,KAAK,CAAC,QAAQ,KAAK,CAAC,EAAE;4BACtB,MAAM,OAAO,GAAG,KAAgB,CAAC;4BACjC,IAAI,OAAO,CAAC,SAAS;gCACjB,OAAO,CAAC,SAAS,CAAC,WAAW,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE;gCAChE,OAAO,OAAO,CAAC;6BAClB;yBACJ;qBACJ;oBAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBAC/C,MAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;wBACnC,IAAI,KAAK,CAAC,QAAQ,KAAK,CAAC,EAAE;4BACtB,MAAM,OAAO,GAAG,KAAgB,CAAC;4BACjC,MAAM,KAAK,GAAG,8BAA8B,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;4BAC7D,IAAI,KAAK,EAAE;gCACP,OAAO,KAAK,CAAC;6BAChB;yBACJ;qBACJ;iBACJ;gBACD,OAAO,SAAS,CAAC;YACrB,CAAC,CAAC;YAEF,MAAM,WAAW,GAAG,KAAK,EAAE,IAAU,EAAE,EAAE;gBAErC,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC;gBAC5B,IAAI,CAAC,IAAI,EAAE;oBACP,OAAO;iBACV;gBACD,MAAM,YAAY,GAAG,WAAW,IAAI,CAAC,eAAe,IAAI,8BAA8B,CAAC,CAAC;gBAExF,IAAI,YAAY,EAAE;oBACd,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC,CAAC;oBAChE,IAAI,CAAC,QAAQ,GAAG,uBAAuB,CAAC;oBACxC,OAAO;iBACV;gBACD,IAAI,QAA4B,CAAC;gBACjC,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;oBACxB,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC5B,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;oBACrB,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;iBAC5B;gBACD,IAAI,CAAC,IAAI,EAAE;oBACP,OAAO;iBACV;gBAED,IAAI,OAAO,GAAG,SAAS,CAAC;gBACxB,IAAI;oBACA,OAAO,GAAG,MAAM,mBAAmB,CAAC,IAAI,CAAC,CAAC;iBAC7C;gBAAC,OAAO,MAAM,EAAE;oBACb,KAAK,CAAC,MAAM,CAAC,CAAC;iBACjB;gBACD,IAAI,CAAC,OAAO,EAAE;oBACV,OAAO;iBACV;gBAED,IAAI,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAY,CAAC,CAAC,CAAC,SAAS,CAAC;gBAClF,IAAI,CAAC,QAAQ,EAAE;oBAKX,QAAQ,GAAG,8BAA8B,CAAC,OAAO,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC;iBAC7E;gBACD,IAAI,CAAC,QAAQ,EAAE;oBACX,KAAK,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;oBAClC,OAAO;iBACV;gBACD,IAAI,QAAQ,CAAC,QAAQ,KAAK,MAAM,EAAE;oBAK9B,QAAQ,GAAG,8BAA8B,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBAC9D;gBACD,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,KAAK,MAAM,EAAE;oBAC3C,KAAK,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;oBAClC,OAAO;iBACV;gBAED,MAAM,GAAG,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;gBACzC,IAAI,CAAC,GAAG,EAAE;oBACN,OAAO;iBACV;gBAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,OAAO,CAAC,4BAA4B,EAAE,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;gBAC7G,IAAI,CAAC,QAAQ,GAAG,uBAAuB,CAAC;YAC5C,CAAC,CAAC;YAEF,MAAM,YAAY,GAAG,KAAK,EAAE,KAAa,EAAE,EAAE;gBACzC,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;oBACtB,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC;oBACxB,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACf,MAAM,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;qBACrC;iBACJ;YACL,CAAC,CAAC;YAEF,IAAI,WAAW,CAAC,QAAQ,EAAE;gBACtB,KAAK,MAAM,IAAI,IAAI,WAAW,CAAC,QAAQ,EAAE;oBACrC,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC;iBAC3B;aACJ;YAED,IAAI,WAAW,CAAC,SAAS,EAAE;gBACvB,KAAK,MAAM,IAAI,IAAI,WAAW,CAAC,SAAS,EAAE;oBACtC,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC;iBAC3B;aACJ;YAED,IAAI,WAAW,CAAC,GAAG,EAAE;gBACjB,MAAM,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;aACvC;YAED,IAAI,CAAC,8BAA8B,EAAE;gBACjC,MAAM,OAAO,GAAG,IAAA,8BAAe,EAAC,WAAW,CAAC,CAAC;gBAC7C,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC1D,OAAmB,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,eAAe,CAAC,CAAC;aACzE;YAED,MAAM,YAAY,GAAG,WAAW,IAAI,CAAC,eAAe,IAAI,8BAA8B,CAAC,CAAC;YACxF,IAAI,YAAY,EAAE;gBACd,KAAK,CAAC,8CAA8C,GAAG,CAAC,8BAA8B,CAAC,CAAC,CAAC,qDAAqD,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAEtJ,MAAM,+BAA+B,GAAG,KAAK,EAAE,QAAqB,EAAwB,EAAE;;oBAC1F,MAAM,OAAO,GAAG,IAAA,8BAAe,EAAC,QAAQ,CAAC,CAAC;oBAC1C,MAAM,gBAAgB,GAAG,IAAA,gCAAiB,EAAc,OAAO,EAAE,yBAAW,CAAC,CAAC;oBAE9E,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE;wBAC5B,gBAAgB,CAAC,QAAQ,GAAG,IAAI,mBAAQ,EAAE,CAAC;qBAC9C;oBACD,gBAAgB,CAAC,QAAQ,CAAC,OAAO,GAAG,6BAA6B,CAAC;oBAElE,MAAM,gBAAgB,GAAG,KAAK,EAAE,IAAU,EAAoB,EAAE;wBAqB5D,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC;wBAC5B,IAAI,CAAC,IAAI,EAAE;4BACP,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;yBAC1B;wBAED,IAAI,QAA4B,CAAC;wBACjC,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;4BACxB,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;4BAC5B,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;4BACrB,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;yBAC5B;wBACD,IAAI,CAAC,IAAI,EAAE;4BACP,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;yBAC1B;wBAED,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC;wBAE5D,IAAI,OAAO,GAAG,SAAS,CAAC;wBACxB,IAAI;4BACA,OAAO,GAAG,MAAM,mBAAmB,CAAC,QAAQ,CAAC,CAAC;yBACjD;wBAAC,OAAO,MAAM,EAAE;4BACb,KAAK,CAAC,MAAM,CAAC,CAAC;yBACjB;wBACD,IAAI,CAAC,OAAO,EAAE;4BACV,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;yBAC1B;wBAED,IAAI,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAY,CAAC,CAAC,CAAC,SAAS,CAAC;wBAClF,IAAI,CAAC,QAAQ,EAAE;4BAKX,QAAQ,GAAG,8BAA8B,CAAC,OAAO,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;yBAC5E;wBACD,IAAI,CAAC,QAAQ,EAAE;4BACX,KAAK,CAAC,kBAAkB,EAAE,IAAI,EAC1B,IAAI,MAAM,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC;4BACvE,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;yBAC9B;wBACD,MAAM,gBAAgB,GAAG,QAAQ,CAAC;wBAClC,IAAI,QAAQ,CAAC,QAAQ,KAAK,OAAO,EAAE;4BAM/B,QAAQ,GAAG,8BAA8B,CACrC,CAAC,QAAQ,CAAC,QAAQ,KAAK,MAAM,IAAI,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;gCACvD,QAAQ,CAAC,UAAqB,CAAC,CAAC;gCAChC,QAAQ,EAAE,IAAI,CAAC,CAAC;yBACvB;wBACD,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,KAAK,OAAO,EAAE;4BAC5C,KAAK,CAAC,kBAAkB,EAAE,IAAI,EAC1B,IAAI,MAAM,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,CAAC,CAAC;4BAChE,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;yBAC9B;wBAED,MAAM,GAAG,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;wBACzC,IAAI,CAAC,GAAG,EAAE;4BACN,KAAK,CAAC,WAAW,CAAC,CAAC;4BACnB,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;yBAC1B;wBAED,MAAM,SAAS,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;wBAE5F,IAAI,SAAS,GAAG,KAAK,CAAC;wBACtB,MAAM,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,IAAA,gCAAgB,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBAG1D,SAAS,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;wBAU9B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,GAAG,GAAG,SAAS,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;wBAE3E,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;wBAC1B,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;wBACnC,IAAI,SAAS,EAAE;4BACX,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;yBAC7B;wBAED,OAAO,IAAI,CAAC;oBAChB,CAAC,CAAC;oBAEF,MAAM,iBAAiB,GAAG,KAAK,EAAE,QAAgB,EAAE,EAAE;wBAEjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BACtC,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;4BACzB,MAAM,IAAI,GAAG,MAAM,gBAAgB,CAAC,IAAI,CAAC,CAAC;4BAC1C,IAAI,CAAC,IAAI,EAAE;gCACP,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gCACtB,CAAC,EAAE,CAAC;gCACJ,KAAK,CAAC,mBAAmB,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;6BAC/D;iCAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;gCACtB,MAAM,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;6BAC1C;yBACJ;oBACL,CAAC,CAAC;oBAEF,IAAI,gBAAgB,CAAC,QAAQ,EAAE;wBAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BACvD,MAAM,IAAI,GAAG,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;4BAC1C,MAAM,IAAI,GAAG,MAAM,gBAAgB,CAAC,IAAI,CAAC,CAAC;4BAC1C,IAAI,CAAC,IAAI,EAAE;gCACP,gBAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gCACvC,CAAC,EAAE,CAAC;gCACJ,KAAK,CAAC,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;6BACrE;yBACJ;qBACJ;oBAED,IAAI,gBAAgB,CAAC,SAAS,EAAE;wBAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BACxD,MAAM,IAAI,GAAG,gBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;4BAC3C,MAAM,IAAI,GAAG,MAAM,gBAAgB,CAAC,IAAI,CAAC,CAAC;4BAC1C,IAAI,CAAC,IAAI,EAAE;gCACP,gBAAgB,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gCACxC,CAAC,EAAE,CAAC;gCACJ,KAAK,CAAC,yBAAyB,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;6BACrE;yBACJ;qBACJ;oBAED,IAAI,gBAAgB,CAAC,GAAG,EAAE;wBACtB,MAAM,iBAAiB,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;qBACjD;oBAED,gBAAgB,CAAC,KAAK,GAAG,EAAE,CAAC;oBAC5B,IAAI,QAAQ,CAAC,KAAK,EAAE;wBAChB,KAAK,MAAM,SAAS,IAAI,QAAQ,CAAC,KAAK,EAAE;4BACpC,IAAI,CAAC,CAAA,MAAA,SAAS,CAAC,aAAa,0CAAE,aAAa,CAAA,EAAE;gCACzC,KAAK,CAAC,8CAA8C,CAAC,CAAC;gCACtD,SAAS;6BACZ;4BAED,IAAI,OAAO,GAAG,SAAS,CAAC;4BACxB,IAAI;gCACA,OAAO,GAAG,MAAM,mBAAmB,CAAC,SAAS,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;6BAC9E;4BAAC,OAAO,MAAM,EAAE;gCACb,KAAK,CAAC,MAAM,CAAC,CAAC;6BACjB;4BACD,IAAI,CAAC,OAAO,EAAE;gCACV,SAAS;6BACZ;4BAED,MAAM,iBAAiB,GAAG,8BAA8B,CAAC,OAAO,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;4BACxF,IAAI,CAAC,iBAAiB,EAAE;gCACpB,KAAK,CAAC,0BAA0B,EAAE,SAAS,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;gCACzE,SAAS;6BACZ;4BAED,MAAM,GAAG,GAAG,iBAAiB,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;4BAClD,IAAI,CAAC,GAAG,EAAE;gCACN,SAAS;6BACZ;4BAED,MAAM,IAAI,GAAG,IAAI,uBAAI,EAAE,CAAC;4BACxB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,aAAa,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;4BAC5F,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;4BAC1B,IAAI,gBAAgB,CAAC,SAAS,EAAE;gCAC5B,MAAM,aAAa,GAAG,gBAAgB,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE;oCAE7D,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,aAAc,CAAC,aAAc,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;gCACxG,CAAC,CAAC,CAAC;gCACH,IAAI,aAAa,IAAI,CAAC,EAAE;oCACpB,MAAM,QAAQ,GAAG,gBAAgB,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC;oCAC3D,IAAI,QAAQ,CAAC,QAAQ,EAAE;wCACnB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;qCACrC;oCAED,gBAAgB,CAAC,SAAS,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;iCACvD;qCAAM;oCACH,MAAM,QAAQ,GAAG,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE;wCAC/C,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC;oCAChC,CAAC,CAAC,CAAC;oCACH,IAAI,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,QAAQ,EAAE;wCACpB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;qCACrC;iCACJ;6BACJ;4BACD,IAAI,SAAS,CAAC,aAAa,CAAC,QAAQ,EAAE;gCAClC,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,aAAa,CAAC,QAAQ,CAAC;6BACpD;4BACD,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;yBACrC;qBACJ;oBACD,OAAO,gBAAgB,CAAC;gBAC5B,CAAC,CAAC;gBAEF,IAAI;oBACA,MAAM,gBAAgB,GAAG,MAAM,+BAA+B,CAAC,WAAW,CAAC,CAAC;oBAC5E,MAAM,YAAY,GAAG,IAAA,8BAAe,EAAC,gBAAgB,CAAC,CAAC;oBACvD,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;oBACrE,IAAI,CAAC,8BAA8B,EAAE;wBAChC,OAAmB,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,qBAAqB,CAAC,CAAC;qBACpF;yBAAM;wBACH,MAAM,kBAAkB,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,8BAA8B,GAAG,gBAAgB,CAAC,CAAC;wBACvG,UAAU,CAAC,kBAAkB,CAAC,CAAC;wBAC/B,EAAE,CAAC,aAAa,CAAC,kBAAkB,EAAE,YAAY,EAAE,MAAM,CAAC,CAAC;wBAC3D,KAAK,CAAC,qCAAqC,GAAG,kBAAkB,CAAC,CAAC;wBAClE,OAAO,CAAC,kBAAkB,CAAC,CAAC;qBAC/B;iBACJ;gBAAC,OAAO,GAAG,EAAE;oBACV,KAAK,CAAC,GAAG,CAAC,CAAC;iBACd;aACJ;SACJ;QAAC,OAAO,MAAM,EAAE;YACb,KAAK,CAAC,MAAM,CAAC,CAAC;SACjB;gBAAS;YACN,KAAK,CAAC,uBAAuB,CAAC,CAAC;YAC/B,IAAI,CAAC,8BAA8B,EAAE;gBACjC,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE;oBACxB,SAAS,GAAG,SAAS,CAAC;oBACtB,MAAM,CAAC,2BAA2B,GAAG,aAAa,CAAC,CAAC;gBACxD,CAAC,EAAE,KAAK,CAAC,CAAC;gBACT,OAAmB,CAAC,GAAG,EAAE,CAAC;aAC9B;SACJ;IACL,CAAC,CAAC,CAAC;AACP,CAAC,CAAC;AA7zCW,QAAA,2BAA2B,+BA6zCtC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as fs from \"fs\";\nimport * as mime from \"mime-types\";\nimport * as path from \"path\";\nimport * as xmldom from \"@xmldom/xmldom\";\nimport * as xpath from \"xpath\";\nimport { ZipFile } from \"yazl\";\n\nimport { MediaOverlayNode, timeStrToSeconds } from \"@models/media-overlay\";\nimport { Metadata } from \"@models/metadata\";\nimport { Properties } from \"@models/metadata-properties\";\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { TaJsonDeserialize, TaJsonSerialize } from \"@r2-lcp-js/serializable\";\nimport { IZip } from \"@r2-utils-js/_utils/zip/zip\";\n\nimport {\n    flattenDaisy2SmilAudioSeq, lazyLoadMediaOverlays, loadFileBufferFromZipPath,\n    loadFileStrFromZipPath, updateDurations,\n} from \"./epub-daisy-common\";\n\nconst debug = debug_(\"r2:shared#parser/daisy-convert-to-epub\");\n\nfunction ensureDirs(fspath: string) {\n    const dirname = path.dirname(fspath);\n\n    if (!fs.existsSync(dirname)) {\n        ensureDirs(dirname);\n        fs.mkdirSync(dirname);\n    }\n}\n\n// this function modifies the input parameter \"publication\"!\nexport const convertDaisyToReadiumWebPub = async (\n    outputDirPath: string,\n    publication: Publication,\n    generateDaisyAudioManifestOnly?: string): Promise<string | undefined> => {\n\n    // debug(\"DEBUG: \", global.JSON.stringify(publication, null, 4));\n\n    return new Promise(async (resolve, reject) => {\n\n        // TODO: textPartAudio / audioPartText?? audioOnly??\n        // https://www.daisy.org/z3986/specifications/Z39-86-2002.html#Type\n        // https://www.daisy.org/z3986/specifications/daisy_202.html\n\n        const isFullTextAudio = publication.Metadata?.AdditionalJSON &&\n            // dtb:multimediaContent ==> audio,text\n            (publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioFullText\" ||\n            publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"] === \"audioFullText\" || (\n                !publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] &&\n                !publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"]\n            ));\n\n        const isAudioOnly = publication.Metadata?.AdditionalJSON &&\n            // dtb:multimediaContent ==> audio\n            (publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioNCX\" ||\n            publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"] === \"audioNcc\");\n\n        const isTextOnly = publication.Metadata?.AdditionalJSON &&\n            // dtb:multimediaContent ==> text\n            (publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"textNCX\" ||\n            publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"] === \"textNcc\");\n\n        if (generateDaisyAudioManifestOnly) {\n            if (isTextOnly) {\n                debug(\"generateDaisyAudioManifestOnly FATAL! text-only publication?? \", publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"], publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"]);\n                return reject(\"generateDaisyAudioManifestOnly cannot process text-only publication\");\n            }\n            if (!isAudioOnly || isFullTextAudio) {\n                debug(\"generateDaisyAudioManifestOnly WARNING! not audio-only publication?? \", publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"], publication.Metadata.AdditionalJSON[\"ncc:multimediaType\"]);\n            }\n        }\n\n        const zipInternal = publication.findFromInternal(\"zip\");\n        if (!zipInternal) {\n            debug(\"No publication zip!?\");\n            return reject(\"No publication zip!?\");\n        }\n        const zip = zipInternal.Value as IZip;\n\n        const nccZipEntry = (await zip.getEntries()).find((entry) => {\n            return /ncc\\.html$/i.test(entry);\n        });\n\n        const outputZipPath = path.join(outputDirPath, `${isAudioOnly ? \"daisy_audioNCX\" : (isTextOnly ? \"daisy_textNCX\" : \"daisy_audioFullText\")}-to-epub.webpub`);\n\n        if (!generateDaisyAudioManifestOnly) {\n            ensureDirs(outputZipPath);\n        }\n\n        let timeoutId: NodeJS.Timeout | undefined;\n        const zipfile = generateDaisyAudioManifestOnly ? undefined : new ZipFile();\n        try {\n            if (!generateDaisyAudioManifestOnly) {\n                const writeStream = fs.createWriteStream(outputZipPath);\n                (zipfile as ZipFile).outputStream.pipe(writeStream)\n                    .on(\"close\", () => {\n                        debug(\"ZIP close\");\n                        if (timeoutId) {\n                            clearTimeout(timeoutId);\n                            timeoutId = undefined;\n                            resolve(outputZipPath);\n                        }\n                    })\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    .on(\"error\", (e: any) => {\n                        debug(\"ZIP error\", e);\n                        reject(e);\n                    });\n            }\n\n            // <dtbook xmlns=\"http://www.daisy.org/z3986/2005/dtbook/\" ...\n            const select = xpath.useNamespaces({\n                dtbook: \"http://www.daisy.org/z3986/2005/dtbook/\",\n                // epub: \"http://www.idpf.org/2007/ops\",\n                // xhtml: \"http://www.w3.org/1999/xhtml\",\n            });\n\n            // http://www.daisy.org/z3986/structure/SG-DAISY3/index-of-elements.html\n            // a\n            // abbr\n            // acronym\n            // address\n            // annoref\n            // annotation\n            // author\n            // bdo\n            // blockquote\n            // bodymatter\n            // book\n            // br\n            // bridgehead\n            // byline\n            // caption\n            // cite\n            // code\n            // col\n            // colgroup\n            // covertitle\n            // dateline\n            // dd\n            // dfn\n            // div\n            // dl\n            // docauthor\n            // doctitle\n            // dt\n            // dtbook\n            // em\n            // epigraph\n            // frontmatter\n            // h1\n            // h2\n            // h3\n            // h4\n            // h5\n            // h6\n            // hd\n            // head\n            // img\n            // imggroup\n            // kbd\n            // level\n            // level1\n            // level2\n            // level3\n            // level4\n            // level5\n            // level6\n            // li\n            // lic\n            // line\n            // linegroup\n            // linenum\n            // link\n            // list\n            // meta\n            // note\n            // noteref\n            // p\n            // pagenum\n            // poem\n            // prodnote\n            // q\n            // rearmatter\n            // samp\n            // sent\n            // sidebar\n            // span\n            // strong\n            // sub\n            // sup\n            // table\n            // tbody\n            // td\n            // tfoot\n            // th\n            // thead\n            // title\n            // tr\n            // w\n\n            const elementNames = [\n                \"address\",\n                \"annoref\",\n                \"annotation\",\n                \"author\",\n                \"bdo\",\n                \"bodymatter\",\n                \"book\",\n                \"bridgehead\",\n                \"byline\",\n                \"caption\",\n                \"cite\",\n                \"col\",\n                \"colgroup\",\n                \"covertitle\",\n                \"dateline\",\n                \"dfn\",\n                \"docauthor\",\n                \"doctitle\",\n                \"dtbook\",\n                \"epigraph\",\n                \"frontmatter\",\n                \"hd\",\n                \"imggroup\",\n                \"kbd\",\n                \"level\",\n                \"levelhd\",\n                \"level1\",\n                \"level2\",\n                \"level3\",\n                \"level4\",\n                \"level5\",\n                \"level6\",\n                \"lic\",\n                \"line\",\n                \"linegroup\",\n                \"linenum\",\n                \"link\",\n                \"list\",\n                \"note\",\n                \"noteref\",\n                \"pagenum\",\n                \"poem\",\n                \"prodnote\",\n                \"rearmatter\",\n                \"samp\",\n                \"sent\",\n                \"sub\",\n                \"sup\",\n                \"q\",\n                \"w\",\n                \"notice\",\n                \"sidebar\",\n                \"blockquote\",\n                \"abbr\",\n                \"acronym\",\n                \"title\",\n            ];\n\n            interface TmoMap {\n                [smilTextRef: string]: {\n                    index: number,\n                    mos: MediaOverlayNode[],\n                };\n            }\n            let mediaOverlaysMap: TmoMap | undefined;\n\n            const getMediaOverlaysDuration = (mo: MediaOverlayNode): number => {\n                let duration = 0;\n\n                if (typeof mo.AudioClipBegin !== \"undefined\" &&\n                    typeof mo.AudioClipEnd !== \"undefined\") {\n\n                    duration = mo.AudioClipEnd - mo.AudioClipBegin;\n\n                } else if (mo.Children) {\n                    for (const child of mo.Children) {\n                        duration += getMediaOverlaysDuration(child);\n                    }\n                }\n\n                return duration;\n            };\n\n            const patchMediaOverlaysTextHref = (\n                mo: MediaOverlayNode,\n                audioOnlySmilHtmlHref: string | undefined): string | undefined => {\n\n                let smilTextRef: string | undefined;\n\n                // && !mo.Text => with audio-only DAISY2.02, points back to ncc.html\n                if (audioOnlySmilHtmlHref && mo.Audio) {\n                    smilTextRef = audioOnlySmilHtmlHref;\n                    mo.Text = `${smilTextRef}#${mo.ParID || mo.TextID || \"_yyy_\"}`;\n                } else if (mo.Text) {\n                    mo.Text = mo.Text.replace(/((\\.xml)|(\\.html))(#.*)?$/i, \".xhtml$4\");\n                    smilTextRef = mo.Text;\n                    const k = smilTextRef.indexOf(\"#\");\n                    if (k > 0) {\n                        smilTextRef = smilTextRef.substr(0, k);\n                    }\n                }\n                if (mo.Children) {\n                    for (const child of mo.Children) {\n                        const smilTextRef_ = patchMediaOverlaysTextHref(child, audioOnlySmilHtmlHref);\n                        if (!smilTextRef_) {\n                            debug(\"########## WARNING: !smilTextRef ???!!\", smilTextRef_, child);\n                        } else if (smilTextRef && smilTextRef !== smilTextRef_) {\n                            debug(\"########## WARNING: smilTextRef !== smilTextRef_ ???!!\", smilTextRef, smilTextRef_);\n                        }\n                        if (!smilTextRef) {\n                            smilTextRef = smilTextRef_;\n                        }\n                    }\n                }\n\n                return smilTextRef;\n            };\n\n            // in-memory cache for expensive SMIL XML DOM parsing\n            const smilDocs: Record<string, Document> = {};\n\n            const loadOrGetCachedSmil = async (smilPathInZip: string): Promise<Document> => {\n\n                let smilDoc = smilDocs[smilPathInZip];\n                if (!smilDoc) {\n                    let smilStr = undefined;\n                    try {\n                        smilStr = await loadFileStrFromZipPath(smilPathInZip, smilPathInZip, zip);\n                    } catch (zipErr) {\n                        debug(zipErr);\n                    }\n                    if (!smilStr) {\n                        debug(\"!loadFileStrFromZipPath 1\", smilPathInZip);\n                        return Promise.reject(\"!loadFileStrFromZipPath 1 \" + smilPathInZip);\n                    }\n                    smilDoc = new xmldom.DOMParser().parseFromString(smilStr, \"application/xml\");\n                    if (nccZipEntry) {\n                        flattenDaisy2SmilAudioSeq(smilPathInZip, smilDoc);\n                    }\n                    smilDocs[smilPathInZip] = smilDoc;\n                }\n                return Promise.resolve(smilDoc);\n            };\n\n            const findLinkInToc = (links: Link[], hrefDecoded: string): Link | undefined => {\n                for (const link of links) {\n                    if (link.HrefDecoded === hrefDecoded) {\n                        return link;\n                    } else if (link.Children) {\n                        const foundLink = findLinkInToc(link.Children, hrefDecoded);\n                        if (foundLink) {\n                            return foundLink;\n                        }\n                    }\n                }\n                return undefined;\n            };\n\n            const createHtmlFromSmilFile = async (smilPathInZip: string): Promise<string | undefined> => {\n                if (generateDaisyAudioManifestOnly) {\n                    return undefined;\n                }\n\n                let smilDoc = undefined;\n                try {\n                    smilDoc = await loadOrGetCachedSmil(smilPathInZip);\n                } catch (zipErr) {\n                    debug(zipErr);\n                }\n                if (!smilDoc) {\n                    return undefined;\n                }\n\n                const smilDocClone = smilDoc.cloneNode(true) as Document;\n\n                let txtCounter = 0;\n\n                // getElementsByName(elementName: string): NodeListOf<HTMLElement>\n                // ==> not available in the XMLDOM API\n                // getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>\n                const parEls = Array.from(smilDocClone.getElementsByTagName(\"par\"));\n                for (const parEl of parEls) {\n\n                    // getElementsByName(elementName: string): NodeListOf<HTMLElement>\n                    // ==> not available in the XMLDOM API\n                    // getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>\n                    const audioElements = Array.from(parEl.getElementsByTagName(\"audio\")).filter((el) => el);\n                    for (const audioElement of audioElements) {\n                        if (audioElement.parentNode) {\n                            audioElement.parentNode.removeChild(audioElement);\n                        }\n                    }\n\n                    let textId: string | undefined | null;\n                    const textElements = Array.from(parEl.getElementsByTagName(\"text\")).filter((el) => el);\n                    for (const textElement of textElements) {\n                        // if (textElement.parentNode) {\n                        //     textElement.parentNode.removeChild(textElement);\n                        // }\n                        const src = textElement.getAttribute(\"src\");\n                        if (src) {\n                            textElement.setAttribute(\"data-src\",\n                                src.replace(/((\\.xml)|(\\.html))(#.*)?$/i, \".xhtml$4\"));\n                            textElement.removeAttribute(\"src\");\n                        }\n\n                        if (!textId) {\n                            textId = textElement.getAttribute(\"id\");\n                        }\n\n                        // // hoist DAISY2 text ID to parent par\n                        // const parId = parEl.getAttribute(\"id\");\n                        // if (!parId) {\n                        //     const txtId = textElement.getAttribute(\"id\");\n                        //     if (txtId) {\n                        //         parEl.setAttribute(\"id\", txtId);\n                        //         textElement.removeAttribute(\"id\");\n                        //     }\n                        // }\n                    }\n\n                    const elmId = parEl.getAttribute(\"id\");\n                    const hrefDecoded = `${smilPathInZip}#${elmId}`;\n                    let tocLinkItem = publication.TOC ? findLinkInToc(publication.TOC, hrefDecoded) : undefined;\n                    if (!tocLinkItem && textId) {\n                        const hrefDecoded_ = `${smilPathInZip}#${textId}`;\n                        tocLinkItem = publication.TOC ? findLinkInToc(publication.TOC, hrefDecoded_) : undefined;\n                    }\n                    const text = tocLinkItem ? tocLinkItem.Title : undefined;\n                    if (text) {\n                        txtCounter = 0;\n                    }\n                    const textNode = smilDocClone.createTextNode(text ? text : `... [${++txtCounter}]`);\n                    parEl.appendChild(textNode);\n                }\n\n                const bodyContent = smilDocClone.getElementsByTagName(\"body\")[0] as Element;\n                const bodyContentStr = new xmldom.XMLSerializer().serializeToString(bodyContent);\n                const contentStr = bodyContentStr\n                    .replace(\"xmlns=\\\"http://www.w3.org/2001/SMIL20/\\\"\", \"\")\n                    .replace(/dur=/g, \"data-dur=\")\n                    .replace(/endsync=/g, \"data-endsync=\")\n                    .replace(/fill=/g, \"data-fill=\")\n                    .replace(/system-required=/g, \"data-system-required=\")\n                    .replace(/customTest=/g, \"data-customTest=\")\n                    .replace(/class=/g, \"data-class=\")\n                    .replace(/<seq/g, \"<div class=\\\"smil-seq\\\"\")\n                    .replace(/<text/g, \"<hr class=\\\"smil-text\\\"\")\n                    .replace(/<par/g, \"<p class=\\\"smil-par\\\"\")\n                    .replace(/<\\/seq>/g, \"</div>\")\n                    .replace(/<\\/par>/g, \"</p>\")\n                    ;\n\n                const htmlDoc = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en\" lang=\"en\">\n    <head>\n        <title>${smilPathInZip}</title>\n    </head>\n    ${contentStr}\n</html>\n`;\n                const htmlFilePath = smilPathInZip.replace(/\\.smil$/i, \".xhtml\");\n                // const fileName = path.parse(href).name;\n                (zipfile as ZipFile).addBuffer(Buffer.from(htmlDoc), htmlFilePath);\n\n                return htmlFilePath;\n            };\n\n            const audioOnlySmilHtmls: Link[] = [];\n\n            if (publication.Spine) {\n                mediaOverlaysMap = {};\n\n                let previousLinkItem: Link | undefined;\n                let spineIndex = -1;\n                for (const linkItem of publication.Spine) {\n                    spineIndex++;\n                    if (!linkItem.MediaOverlays) {\n                        continue;\n                    }\n\n                    if (!linkItem.MediaOverlays.initialized) {\n                        // mo.initialized true/false is automatically handled\n                        await lazyLoadMediaOverlays(publication, linkItem.MediaOverlays);\n\n                        if (isFullTextAudio || isAudioOnly) {\n                            updateDurations(linkItem.MediaOverlays.duration, linkItem);\n                        }\n                    }\n\n                    if (isFullTextAudio || isAudioOnly) {\n                        const computedDur = getMediaOverlaysDuration(linkItem.MediaOverlays);\n                        if (computedDur) {\n                            if (!linkItem.MediaOverlays.duration) {\n                                linkItem.MediaOverlays.duration = computedDur;\n\n                                updateDurations(computedDur, linkItem);\n                            } else {\n                                if (linkItem.MediaOverlays.duration !== computedDur) {\n                                    debug(\"linkItem.MediaOverlays.duration !== computedDur\",\n                                        linkItem.MediaOverlays.duration, computedDur);\n                                }\n                            }\n                        }\n\n                        if (previousLinkItem && previousLinkItem.MediaOverlays &&\n                            // !previousLinkItem.MediaOverlays.duration &&\n                            typeof previousLinkItem.MediaOverlays.totalElapsedTime !== \"undefined\" &&\n                            typeof linkItem.MediaOverlays.totalElapsedTime !== \"undefined\") {\n\n                            const dur = linkItem.MediaOverlays.totalElapsedTime -\n                                previousLinkItem.MediaOverlays.totalElapsedTime;\n                            if (dur > 0) {\n                                if (!previousLinkItem.MediaOverlays.duration) {\n                                    previousLinkItem.MediaOverlays.duration = dur;\n\n                                    updateDurations(dur, previousLinkItem);\n                                } else {\n                                    if (previousLinkItem.MediaOverlays.duration !== dur) {\n                                        debug(\"previousLinkItem.MediaOverlays.duration !== dur\",\n                                            previousLinkItem.MediaOverlays.duration, dur);\n                                    }\n                                }\n                            }\n                        }\n                        previousLinkItem = linkItem;\n                    }\n\n                    // if (generateDaisyAudioManifestOnly) {\n                    //     continue;\n                    // }\n\n                    let smilTextRef: string | undefined;\n\n                    const isAudioOnly_ = isAudioOnly || (isFullTextAudio && generateDaisyAudioManifestOnly);\n\n                    if (isAudioOnly_) {\n                        const audioOnlySmilHtmlHref =\n                            linkItem.MediaOverlays.SmilPathInZip?.replace(/\\.smil$/i, \".xhtml\");\n                        if (audioOnlySmilHtmlHref) {\n                            smilTextRef = patchMediaOverlaysTextHref(linkItem.MediaOverlays, audioOnlySmilHtmlHref);\n                        }\n                    } else {\n                        smilTextRef = patchMediaOverlaysTextHref(linkItem.MediaOverlays, undefined);\n                    }\n\n                    if (smilTextRef) {\n                        if (isAudioOnly_ && linkItem.MediaOverlays.SmilPathInZip) {\n                            await createHtmlFromSmilFile(linkItem.MediaOverlays.SmilPathInZip);\n\n                            const smilHtml = new Link();\n                            smilHtml.Href = smilTextRef;\n                            smilHtml.TypeLink = \"application/xhtml+xml\";\n                            audioOnlySmilHtmls.push(smilHtml);\n                        }\n\n                        // spineIndex++;\n                        if (!mediaOverlaysMap[smilTextRef]) {\n                            mediaOverlaysMap[smilTextRef] = {\n                                index: spineIndex,\n                                mos: [],\n                            };\n                        }\n                        // captures the last index in the reading order\n                        mediaOverlaysMap[smilTextRef].index = spineIndex;\n                        mediaOverlaysMap[smilTextRef].mos.push(linkItem.MediaOverlays);\n                    }\n                }\n            }\n            publication.Spine = [];\n\n            const resourcesToKeep: Link[] = [];\n\n            const dtBooks: Link[] = [...audioOnlySmilHtmls];\n\n            // reference copy! (not by value) so we can publication.Resources.push(...) safely within the loop\n            // const resources = [...publication.Resources];\n            // ... but we completely replace the array of Links, so this is fine:\n            for (const resLink of publication.Resources) {\n                // relative to publication root (package.opf / ReadiumWebPubManifest.json)\n                if (!resLink.HrefDecoded) {\n                    continue;\n                }\n                if (resLink.TypeLink === \"text/css\" || /\\.css$/i.test(resLink.HrefDecoded)) {\n                    if (generateDaisyAudioManifestOnly) {\n                        debug(\"generateDaisyAudioManifestOnly => skip resource: \", resLink.HrefDecoded);\n                        continue;\n                    }\n\n                    let cssText = undefined;\n                    try {\n                        cssText = await loadFileStrFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    } catch (zipErr) {\n                        debug(zipErr);\n                    }\n                    if (!cssText) {\n                        debug(\"!loadFileStrFromZipPath 2\", resLink.HrefDecoded);\n                        continue;\n                    }\n\n                    // replace comments\n                    cssText = cssText.replace(/\\/\\*([\\s\\S]+?)\\*\\//gm, (_match, p1, _offset, _string) => {\n                        const base64 = Buffer.from(p1).toString(\"base64\");\n                        return `/*__${base64}__*/`;\n                    });\n\n                    // const regex = new RegExp(`[^#\\.](${elementNames.join(\"|\")})`, \"g\");\n                    for (const elementName of elementNames) {\n                        // meant to patch CSS selectors, but not property values\n                        const regex = new RegExp(\n                            `([^#\\.a-zA-Z0-9\\-_])(${elementName})([^a-zA-Z0-9\\-_;])`, \"g\");\n                        // let i = -1;\n                        // let match: RegExpExecArray | null;\n                        // // tslint:disable-next-line: no-conditional-assignment\n                        // while (match = regex.exec(cssText)) {\n                        //     i++;\n                        //     debug(\"A -----------\");\n                        //     debug(i, elementName, `$_$_$${match[0]}$_$_$`,\n                        // `===${match[1]}^^^${match[2]}^^^${match[3]}===`);\n                        //     debug(\"B -----------\");\n                        // }\n                        cssText = cssText.replace(regex, \"$1.$2_R2$3\");\n\n                        // second pass, as the first doesn't match tokens with trailing / leading separators\n                        cssText = cssText.replace(regex, \"$1.$2_R2$3\");\n                    }\n\n                    // restore comments\n                    cssText = cssText.replace(/\\/\\*__([\\s\\S]+?)__\\*\\//g, (_match, p1, _offset, _string) => {\n                        const comment = Buffer.from(p1, \"base64\").toString(\"utf8\");\n                        return `/*${comment}*/`;\n                    });\n\n                    // const newCssFilePath = resLink.HrefDecoded.replace(/\\.css$/i, \"__.css\");\n                    // const cssOutputFilePath = path.join(outputDirPathExploded, newCssFilePath);\n                    // ensureDirs(cssOutputFilePath);\n                    // fs.writeFileSync(cssOutputFilePath, cssText);\n                    (zipfile as ZipFile).addBuffer(Buffer.from(cssText), resLink.HrefDecoded);\n\n                    // const resLinkJson = TaJsonSerialize(resLink);\n                    // // resLinkJson.href = newCssFilePath;\n                    // const resLinkClone = TaJsonDeserialize<Link>(resLinkJson, Link);\n                    // resLinkClone.setHrefDecoded(newCssFilePath);\n\n                    resourcesToKeep.push(resLink);\n\n                } else if (resLink.TypeLink === \"application/x-dtbook+xml\" || /\\.xml$/i.test(resLink.HrefDecoded)) {\n                    if (isAudioOnly || generateDaisyAudioManifestOnly) {\n                        debug(\"generateDaisyAudioManifestOnly or isAudioOnly => skip resource: \", resLink.HrefDecoded);\n                        continue;\n                    }\n\n                    let dtBookStr = undefined;\n                    try {\n                        dtBookStr = await loadFileStrFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    } catch (zipErr) {\n                        debug(zipErr);\n                    }\n                    if (!dtBookStr) {\n                        debug(\"!loadFileStrFromZipPath 3\", dtBookStr);\n                        continue;\n                    }\n                    dtBookStr = dtBookStr.replace(/xmlns=\"\"/, \" \");\n                    dtBookStr = dtBookStr.replace(/<dtbook/, \"<dtbook xmlns:epub=\\\"http://www.idpf.org/2007/ops\\\" \");\n                    const dtBookDoc = new xmldom.DOMParser().parseFromString(dtBookStr, \"application/xml\");\n\n                    let title = dtBookDoc.getElementsByTagName(\"doctitle\")[0]?.textContent;\n                    if (title) {\n                        title = title.trim();\n                        if (!title.length) {\n                            title = null;\n                        }\n                    }\n\n                    const listElements = dtBookDoc.getElementsByTagName(\"list\");\n                    for (let i = 0; i < listElements.length; i++) {\n                        const listElement = listElements.item(i);\n                        if (!listElement) {\n                            continue;\n                        }\n                        const type = listElement.getAttribute(\"type\");\n                        if (type) {\n                            // TODO: strictly-speaking, this is a read-only property!\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            (listElement as any).tagName = type;\n                            // listElement.removeAttribute(\"type\");\n                        }\n                    }\n\n                    //             .replace(/(<\\/?)imggroup/g, \"$1figure\")\n                    //             .replace(/<caption/g, \"<figcaption\")\n                    //             .replace(/<\\/caption>/g, \"</figcaption>\");\n\n                    for (const elementName of elementNames) {\n                        // getElementsByName(elementName: string): NodeListOf<HTMLElement>\n                        // ==> not available in the XMLDOM API\n                        // getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>\n                        // ==> mutates during loop because of tagName reassignment!\n                        const els = Array.from(dtBookDoc.getElementsByTagName(elementName)).filter((el) => el);\n                        for (const el of els) {\n                            el.setAttribute(\"data-dtbook\", elementName);\n                            const cls = el.getAttribute(\"class\");\n                            el.setAttribute(\"class\", `${cls ? (cls + \" \") : \"\"}${elementName}_R2`);\n                            // TODO: strictly-speaking, this is a read-only property!\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            (el as any).tagName =\n                                ((elementName === \"dtbook\") ? \"html\" :\n                                    ((elementName === \"book\") ? \"body\" :\n                                        ((elementName === \"pagenum\") ? \"span\" :\n                                            ((elementName === \"sent\") ? \"span\" :\n                                                ((elementName === \"caption\") ? \"figcaption\" :\n                                                    ((elementName === \"imggroup\") ? \"figure\" :\n                                                        (elementName === \"sidebar\") ? \"aside\" :\n                                                            \"div\"))))));\n                            if (elementName === \"pagenum\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"pagebreak\");\n                                el.setAttribute(\"epub:type\", \"pagebreak\");\n                            } else if (elementName === \"annotation\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"annotation\");\n                                el.setAttribute(\"epub:type\", \"annotation\");\n                            } else if (elementName === \"note\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"note\");\n                                el.setAttribute(\"epub:type\", \"note\");\n                            } else if (elementName === \"prodnote\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"note\");\n                                el.setAttribute(\"epub:type\", \"note\");\n                            } else if (elementName === \"sidebar\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"sidebar\");\n                                el.setAttribute(\"epub:type\", \"sidebar\");\n                            }\n                        }\n                    }\n\n                    // <?xml-stylesheet type=\"text/css\" href=\"dtbookbasic.css\"?>\n                    const stylesheets =\n                        select(\"/processing-instruction('xml-stylesheet')\", dtBookDoc) as ProcessingInstruction[];\n                    const cssHrefs: string[] = []; // `<link rel=\"stylesheet\" href=\"${cssHref}\" />`\n                    for (const stylesheet of stylesheets) {\n                        if (!stylesheet.nodeValue) {\n                            continue;\n                        }\n                        if (!stylesheet.nodeValue.includes(\"text/css\")) {\n                            continue;\n                        }\n                        const match = stylesheet.nodeValue.match(/href=(\"|')(.*?)(\"|')/);\n                        if (!match) {\n                            continue;\n                        }\n                        const href = match[2].trim();\n                        if (href) {\n                            cssHrefs.push(href);\n                        }\n                    }\n\n                    const smilRefs = select(\"//*[@smilref]\", dtBookDoc) as Element[];\n                    for (const smilRef of smilRefs) {\n                        const ref = smilRef.getAttribute(\"smilref\");\n                        if (ref) {\n                            smilRef.setAttribute(\"data-smilref\", ref);\n                        }\n                        smilRef.removeAttribute(\"smilref\");\n                    }\n\n                    // does not work (element renamed via the tagName assignment still have the original NameSpaceURI,\n                    // which gets serialized)\n                    // dtBookDoc.documentElement.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n\n                    // does not work (read only property):\n                    // (dtBookDoc as any).doctype = null;\n                    // ...so we use regexp replace below\n\n                    const dtbookNowXHTML = new xmldom.XMLSerializer().serializeToString(dtBookDoc)\n                        .replace(/xmlns=\"http:\\/\\/www\\.daisy\\.org\\/z3986\\/2005\\/dtbook\\/\"/, \"xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\")\n                        .replace(/xmlns=\"http:\\/\\/www\\.daisy\\.org\\/z3986\\/2005\\/dtbook\\/\"/g, \" \")\n                        .replace(/^([\\s\\S]*)<html/gm,\n                            `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html `)\n                        .replace(/<head([\\s\\S]*?)>/gm,\n                            `\n<head$1>\n<meta charset=\"UTF-8\" />\n${title ? `<title>${title}</title>` : \"\"}\n`)\n                        .replace(/<\\/head[\\s\\S]*?>/gm,\n                            `\n${cssHrefs.reduce((pv, cv) => {\n                                return pv + \"\\n\" + `<link rel=\"stylesheet\" type=\"text/css\" href=\"${cv}\" />`;\n                            }, \"\")}\n</head>\n`);\n                    const xhtmlFilePath = resLink.HrefDecoded.replace(/\\.([^\\.]+)$/i, \".xhtml\");\n\n                    // const xhtmlOutputFilePath = path.join(outputDirPathExploded, xhtmlFilePath);\n                    // ensureDirs(xhtmlOutputFilePath);\n                    // fs.writeFileSync(xhtmlOutputFilePath, dtbookNowXHTML);\n                    // zipfile.addFile(xhtmlOutputFilePath, xhtmlFilePath);\n                    (zipfile as ZipFile).addBuffer(Buffer.from(dtbookNowXHTML), xhtmlFilePath);\n\n                    const resLinkJson = TaJsonSerialize(resLink);\n                    // resLinkJson.href = xhtmlFilePath;\n                    const resLinkClone = TaJsonDeserialize<Link>(resLinkJson, Link);\n                    resLinkClone.setHrefDecoded(xhtmlFilePath);\n                    resLinkClone.TypeLink = \"application/xhtml+xml\";\n\n                    dtBooks.push(resLinkClone);\n\n                } else if (!/\\.opf$/i.test(resLink.HrefDecoded) &&\n                    !/\\.res$/i.test(resLink.HrefDecoded) &&\n                    !/\\.ncx$/i.test(resLink.HrefDecoded) &&\n                    !/ncc\\.html$/i.test(resLink.HrefDecoded)) {\n\n                    // if (generateDaisyAudioManifestOnly) {\n                    //     debug(\"generateDaisyAudioManifestOnly => skip resource: \", resLink.HrefDecoded);\n                    //     continue;\n                    // }\n\n                    const buff = generateDaisyAudioManifestOnly ? undefined : await loadFileBufferFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n\n                    if (/\\.html$/i.test(resLink.HrefDecoded)) {\n                        resLink.setHrefDecoded(resLink.HrefDecoded.replace(/\\.html$/i, \".xhtml\"));\n                    }\n\n                    if (buff) {\n                        (zipfile as ZipFile).addBuffer(buff, resLink.HrefDecoded);\n                    }\n\n                    resourcesToKeep.push(resLink);\n\n                    if (/\\.x?html$/i.test(resLink.HrefDecoded) ||\n                        resLink.TypeLink === \"text/html\" ||\n                        resLink.TypeLink === \"application/xhtml+xml\") {\n\n                        if (resLink.TypeLink === \"text/html\") {\n                            resLink.TypeLink = \"application/xhtml+xml\";\n                        }\n                        dtBooks.push(resLink);\n                    }\n                }\n            }\n\n            if (mediaOverlaysMap) {\n                Object.keys(mediaOverlaysMap).forEach((smilTextRef) => {\n                    if (!mediaOverlaysMap) { // compiler check\n                        return;\n                    }\n                    debug(\"smilTextRef: \" + smilTextRef);\n                    const mos = mediaOverlaysMap[smilTextRef].mos;\n                    if (mos.length === 1) { // single-item array\n                        debug(\"smilTextRef [1]: \" + smilTextRef);\n                        return;\n                    }\n\n                    const mergedMediaOverlays = new MediaOverlayNode();\n                    mergedMediaOverlays.SmilPathInZip = undefined;\n                    mergedMediaOverlays.initialized = true;\n                    mergedMediaOverlays.Role = [];\n                    mergedMediaOverlays.Role.push(\"section\");\n                    mergedMediaOverlays.duration = 0;\n\n                    let i = -1;\n                    for (const mo of mos) {\n                        i++;\n                        if (mo.Children) {\n                            debug(`smilTextRef [${i}]: ` + smilTextRef);\n\n                            if (!mergedMediaOverlays.Children) {\n                                mergedMediaOverlays.Children = [];\n                            }\n                            mergedMediaOverlays.Children = mergedMediaOverlays.Children.concat(mo.Children);\n\n                            if (mo.duration) {\n                                mergedMediaOverlays.duration += mo.duration;\n                            }\n                        }\n                    }\n                    mediaOverlaysMap[smilTextRef].mos = [mergedMediaOverlays]; // single-item array\n                });\n\n                const mediaOverlaysSequence = Object.keys(mediaOverlaysMap).map((smilTextRef) => {\n                    if (!mediaOverlaysMap) { // compiler check\n                        return undefined;\n                    }\n                    return {\n                        index: mediaOverlaysMap[smilTextRef].index,\n                        mo: mediaOverlaysMap[smilTextRef].mos[0], // single-item array, at this point\n                        smilTextRef,\n                    };\n                }).filter((e) => e).sort((a, b) => {\n                    // a less than b\n                    if (a && b && a.index < b.index) {\n                        return -1;\n                    }\n                    // a more than b\n                    if (a && b && a.index > b.index) {\n                        return 1;\n                    }\n                    // a === b\n                    return 0;\n                });\n\n                for (const mediaOverlay of mediaOverlaysSequence) {\n                    if (!mediaOverlay) { // compiler check\n                        continue;\n                    }\n                    debug(\"mediaOverlay:\", mediaOverlay.index, mediaOverlay.smilTextRef);\n\n                    const dtBookLink = dtBooks.find((l) => {\n                        return l.HrefDecoded && mediaOverlay.smilTextRef ?\n                            // TODO: do we need to cover the case sensitivity edge case,\n                            // and if so, what about the myriad of other HREF comparisons in this codebase??\n                            l.HrefDecoded.toLowerCase() === mediaOverlay.smilTextRef.toLowerCase()\n                            : false;\n                    });\n\n                    if (!dtBookLink) {\n                        debug(\"!!dtBookLink\", mediaOverlay.smilTextRef, JSON.stringify(dtBooks, null, 4));\n                    } else if (dtBookLink.HrefDecoded && mediaOverlay.smilTextRef &&\n                        // TODO: do we need to cover the case sensitivity edge case,\n                        // and if so, what about the myriad of other HREF comparisons in this codebase??\n                        dtBookLink.HrefDecoded.toLowerCase() !== mediaOverlay.smilTextRef.toLowerCase()) {\n\n                        debug(\"dtBook.HrefDecoded !== mediaOverlay.smilTextRef\",\n                            dtBookLink.HrefDecoded, mediaOverlay.smilTextRef);\n                    } else {\n                        if (isFullTextAudio || isAudioOnly) {\n                            dtBookLink.MediaOverlays = mediaOverlay.mo;\n\n                            if (mediaOverlay.mo.duration) {\n                                dtBookLink.Duration = mediaOverlay.mo.duration;\n                            }\n\n                            const moURL = `smil-media-overlays_${mediaOverlay.index}.json`;\n                            // mediaOverlayURLPath + \"?\" +\n                            //     mediaOverlayURLParam + \"=\" +\n                            //     encodeURIComponent_RFC3986(\n                            //         resLinkClone.HrefDecoded ? resLinkClone.HrefDecoded : resLinkClone.Href);\n\n                            // legacy method:\n                            if (!dtBookLink.Properties) {\n                                dtBookLink.Properties = new Properties();\n                            }\n                            dtBookLink.Properties.MediaOverlay = moURL;\n\n                            // new method:\n                            // tslint:disable-next-line: max-line-length\n                            // https://w3c.github.io/sync-media-pub/incorporating-synchronized-narration.html#with-webpub\n                            if (!dtBookLink.Alternate) {\n                                dtBookLink.Alternate = [];\n                            }\n                            const moLink = new Link();\n                            moLink.Href = moURL;\n                            moLink.TypeLink = \"application/vnd.syncnarr+json\";\n                            moLink.Duration = dtBookLink.Duration;\n                            dtBookLink.Alternate.push(moLink);\n\n                            if (!generateDaisyAudioManifestOnly) {\n                                const jsonObjMO = TaJsonSerialize(mediaOverlay.mo);\n                                const jsonStrMO = global.JSON.stringify(jsonObjMO, null, \"  \");\n                                (zipfile as ZipFile).addBuffer(Buffer.from(jsonStrMO), moURL);\n                            }\n\n                            debug(\"dtBookLink IN SPINE:\",\n                                mediaOverlay.index, dtBookLink.HrefDecoded, dtBookLink.Duration, moURL);\n                        } else {\n                            debug(\"dtBookLink IN SPINE (no audio):\", mediaOverlay.index, dtBookLink.HrefDecoded);\n                        }\n                        publication.Spine.push(dtBookLink);\n                    }\n                }\n            }\n\n            publication.Resources = resourcesToKeep;\n\n            if (!publication.Metadata) {\n                publication.Metadata = new Metadata();\n            }\n            // publication.Metadata.Source = \"DAISY\";\n            if (!publication.Metadata.AdditionalJSON) {\n                publication.Metadata.AdditionalJSON = {};\n            }\n            publication.Metadata.AdditionalJSON.ReadiumWebPublicationConvertedFrom =\n                isAudioOnly ? \"DAISY_audioNCX\" : (isTextOnly ? \"DAISY_textNCX\" : \"DAISY_audioFullText\");\n\n            const findFirstDescendantTextOrAudio = (parent: Element, audio: boolean): Element | undefined => {\n                if (parent.childNodes && parent.childNodes.length) {\n                    // tslint:disable-next-line: prefer-for-of\n                    for (let i = 0; i < parent.childNodes.length; i++) {\n                        const child = parent.childNodes[i];\n                        if (child.nodeType === 1) { // Node.ELEMENT_NODE\n                            const element = child as Element;\n                            if (element.localName &&\n                                element.localName.toLowerCase() === (audio ? \"audio\" : \"text\")) {\n                                return element;\n                            }\n                        }\n                    }\n                    // tslint:disable-next-line: prefer-for-of\n                    for (let i = 0; i < parent.childNodes.length; i++) {\n                        const child = parent.childNodes[i];\n                        if (child.nodeType === 1) { // Node.ELEMENT_NODE\n                            const element = child as Element;\n                            const found = findFirstDescendantTextOrAudio(element, audio);\n                            if (found) {\n                                return found;\n                            }\n                        }\n                    }\n                }\n                return undefined;\n            };\n\n            const processLink = async (link: Link) => {\n                // relative to publication root (package.opf / ReadiumWebPubManifest.json)\n                let href = link.HrefDecoded;\n                if (!href) {\n                    return;\n                }\n                const isAudioOnly_ = isAudioOnly || (isFullTextAudio && generateDaisyAudioManifestOnly);\n\n                if (isAudioOnly_) {\n                    link.setHrefDecoded(href.replace(/\\.smil(#.*)?$/i, \".xhtml$1\"));\n                    link.TypeLink = \"application/xhtml+xml\";\n                    return;\n                }\n                let fragment: string | undefined;\n                if (href.indexOf(\"#\") >= 0) {\n                    const arr = href.split(\"#\");\n                    href = arr[0].trim();\n                    fragment = arr[1].trim();\n                }\n                if (!href) {\n                    return;\n                }\n\n                let smilDoc = undefined;\n                try {\n                    smilDoc = await loadOrGetCachedSmil(href);\n                } catch (zipErr) {\n                    debug(zipErr);\n                }\n                if (!smilDoc) {\n                    return;\n                }\n\n                let targetEl = fragment ? smilDoc.getElementById(fragment) as Element : undefined;\n                if (!targetEl) {\n                    // const textElems = smilDoc.getElementsByTagName(\"text\");\n                    // if (textElems && textElems[0]) {\n                    //     targetEl = textElems[0];\n                    // }\n                    targetEl = findFirstDescendantTextOrAudio(smilDoc.documentElement, false);\n                }\n                if (!targetEl) {\n                    debug(\"--??-- !targetEl1 \", href);\n                    return;\n                }\n                if (targetEl.nodeName !== \"text\") {\n                    // const textElems = select(\"//text\", targetEl, true) as Element;\n                    // if (textElems) {\n                    //     targetEl = textElems;\n                    // }\n                    targetEl = findFirstDescendantTextOrAudio(targetEl, false);\n                }\n                if (!targetEl || targetEl.nodeName !== \"text\") {\n                    debug(\"--??-- !targetEl2 \", href);\n                    return;\n                }\n\n                const src = targetEl.getAttribute(\"src\");\n                if (!src) {\n                    return;\n                }\n\n                link.Href = path.join(href, \"..\", src.replace(/((\\.xml)|(\\.html))(#.*)?$/i, \".xhtml$4\")).replace(/\\\\/g, \"/\");\n                link.TypeLink = \"application/xhtml+xml\";\n            };\n\n            const processLinks = async (links: Link[]) => {\n                for (const link of links) {\n                    await processLink(link);\n                    if (link.Children) {\n                        await processLinks(link.Children);\n                    }\n                }\n            };\n\n            if (publication.PageList) {\n                for (const link of publication.PageList) {\n                    await processLink(link);\n                }\n            }\n\n            if (publication.Landmarks) {\n                for (const link of publication.Landmarks) {\n                    await processLink(link);\n                }\n            }\n\n            if (publication.TOC) {\n                await processLinks(publication.TOC);\n            }\n\n            if (!generateDaisyAudioManifestOnly) {\n                const jsonObj = TaJsonSerialize(publication);\n                const jsonStr = global.JSON.stringify(jsonObj, null, \"  \");\n                (zipfile as ZipFile).addBuffer(Buffer.from(jsonStr), \"manifest.json\");\n            }\n\n            const isAudioOnly_ = isAudioOnly || (isFullTextAudio && generateDaisyAudioManifestOnly);\n            if (isAudioOnly_) {\n                debug(\"DAISY audio only book => manifest-audio.json\" + (generateDaisyAudioManifestOnly ? \" (generateDaisyAudioManifestOnly ***_manifest.json)\" : \"\"));\n\n                const transformPublicationToAudioBook = async (pubAudio: Publication): Promise<Publication> => {\n                    const pubJson = TaJsonSerialize(pubAudio);\n                    const audioPublication = TaJsonDeserialize<Publication>(pubJson, Publication);\n\n                    if (!audioPublication.Metadata) {\n                        audioPublication.Metadata = new Metadata();\n                    }\n                    audioPublication.Metadata.RDFType = \"http://schema.org/Audiobook\";\n\n                    const processLinkAudio = async (link: Link): Promise<boolean> => {\n\n                        // ALTERNATE is the audio \"label\" for the link, not the link destination!!\n                        // See addAlternateAudioLinkFromNCX()\n                        // if (link.Alternate) {\n                        //     const audioLink = link.Alternate.find((l) => {\n                        //         return l.TypeLink?.startsWith(\"audio/\");\n                        //     });\n                        //     if (audioLink) { // remove clipEnd\n                        //         link.setHrefDecoded(audioLink.Href.replace(/^(.+)#t=(.+),(.*)$/, \"$1#t=$2\"));\n                        //         link.TypeLink = audioLink.TypeLink;\n                        //     }\n\n                        //     // tslint:disable-next-line\n                        //     // @tsxxx-ignore: TS2790 (The operand of a 'delete' operator must be optional)\n                        //     // delete link.Alternate;\n                        //     // link.Alternate = [];\n                        //     (link.Alternate as any) = undefined;\n                        // }\n\n                        // relative to publication root (package.opf / ReadiumWebPubManifest.json)\n                        let href = link.HrefDecoded;\n                        if (!href) {\n                            return !!link.Children;\n                        }\n\n                        let fragment: string | undefined;\n                        if (href.indexOf(\"#\") >= 0) {\n                            const arr = href.split(\"#\");\n                            href = arr[0].trim();\n                            fragment = arr[1].trim();\n                        }\n                        if (!href) {\n                            return !!link.Children;\n                        }\n\n                        const smilHref = href.replace(/\\.xhtml(#.*)?$/i, \".smil$1\");\n\n                        let smilDoc = undefined;\n                        try {\n                            smilDoc = await loadOrGetCachedSmil(smilHref);\n                        } catch (zipErr) {\n                            debug(zipErr);\n                        }\n                        if (!smilDoc) {\n                            return !!link.Children;\n                        }\n\n                        let targetEl = fragment ? smilDoc.getElementById(fragment) as Element : undefined;\n                        if (!targetEl) {\n                            // const textElems = smilDoc.getElementsByTagName(\"text\");\n                            // if (textElems && textElems[0]) {\n                            //     targetEl = textElems[0];\n                            // }\n                            targetEl = findFirstDescendantTextOrAudio(smilDoc.documentElement, true);\n                        }\n                        if (!targetEl) {\n                            debug(\"==?? !targetEl1 \", href,\n                                new xmldom.XMLSerializer().serializeToString(smilDoc.documentElement));\n                                return !!link.Children;\n                        }\n                        const targetElOriginal = targetEl;\n                        if (targetEl.nodeName !== \"audio\") {\n\n                            // const textElems = select(\"//text\", targetEl, true) as Element;\n                            // if (textElems) {\n                            //     targetEl = textElems;\n                            // }\n                            targetEl = findFirstDescendantTextOrAudio(\n                                (targetEl.nodeName === \"text\" && targetEl.parentNode) ?\n                                targetEl.parentNode as Element :\n                                targetEl, true);\n                        }\n                        if (!targetEl || targetEl.nodeName !== \"audio\") {\n                            debug(\"==?? !targetEl2 \", href,\n                                new xmldom.XMLSerializer().serializeToString(targetElOriginal));\n                                return !!link.Children;\n                        }\n\n                        const src = targetEl.getAttribute(\"src\");\n                        if (!src) {\n                            debug(\"==?? !src\");\n                            return !!link.Children;\n                        }\n\n                        const clipBegin = targetEl.getAttribute(\"clipBegin\") || targetEl.getAttribute(\"clip-begin\");\n                        // const clipEnd = targetEl.getAttribute(\"clipEnd\") || targetEl.getAttribute(\"clip-end\");\n                        let timeStamp = \"#t=\";\n                        const begin = clipBegin ? timeStrToSeconds(clipBegin) : 0;\n                        // const end = clipEnd ? timeStrToSeconds(clipEnd) : 0;\n\n                        timeStamp += begin.toString();\n                        // if (clipEnd && end) {\n                        //     timeStamp += \",\";\n                        //     timeStamp += end.toString();\n                        // }\n\n                        // if (clipEnd && end > begin) {\n                        //     link.Duration = end - begin;\n                        // }\n\n                        link.Href = path.join(smilHref, \"..\", src + timeStamp).replace(/\\\\/g, \"/\");\n\n                        link.TypeLink = \"audio/?\";\n                        const mediaType = mime.lookup(src);\n                        if (mediaType) {\n                            link.TypeLink = mediaType;\n                        }\n\n                        return true;\n                    };\n\n                    const processLinksAudio = async (children: Link[]) => {\n\n                        for (let i = 0; i < children.length; i++) {\n                            const link = children[i];\n                            const keep = await processLinkAudio(link);\n                            if (!keep) {\n                                children.splice(i, 1);\n                                i--;\n                                debug(\"LINK DELETE TOC: \", link.Href, typeof link.Children);\n                            } else if (link.Children) {\n                                await processLinksAudio(link.Children);\n                            }\n                        }\n                    };\n\n                    if (audioPublication.PageList) {\n                        for (let i = 0; i < audioPublication.PageList.length; i++) {\n                            const link = audioPublication.PageList[i];\n                            const keep = await processLinkAudio(link);\n                            if (!keep) {\n                                audioPublication.PageList.splice(i, 1);\n                                i--;\n                                debug(\"LINK DELETE page list: \", link.Href, typeof link.Children);\n                            }\n                        }\n                    }\n\n                    if (audioPublication.Landmarks) {\n                        for (let i = 0; i < audioPublication.Landmarks.length; i++) {\n                            const link = audioPublication.Landmarks[i];\n                            const keep = await processLinkAudio(link);\n                            if (!keep) {\n                                audioPublication.Landmarks.splice(i, 1);\n                                i--;\n                                debug(\"LINK DELETE landmarks: \", link.Href, typeof link.Children);\n                            }\n                        }\n                    }\n\n                    if (audioPublication.TOC) {\n                        await processLinksAudio(audioPublication.TOC);\n                    }\n\n                    audioPublication.Spine = [];\n                    if (pubAudio.Spine) {\n                        for (const spineLink of pubAudio.Spine) {\n                            if (!spineLink.MediaOverlays?.SmilPathInZip) {\n                                debug(\"???- !spineLink.MediaOverlays?.SmilPathInZip\");\n                                continue;\n                            }\n\n                            let smilDoc = undefined;\n                            try {\n                                smilDoc = await loadOrGetCachedSmil(spineLink.MediaOverlays.SmilPathInZip);\n                            } catch (zipErr) {\n                                debug(zipErr);\n                            }\n                            if (!smilDoc) {\n                                continue;\n                            }\n\n                            const firstAudioElement = findFirstDescendantTextOrAudio(smilDoc.documentElement, true);\n                            if (!firstAudioElement) {\n                                debug(\"???- !firstAudioElement \", spineLink.MediaOverlays.SmilPathInZip);\n                                continue;\n                            }\n\n                            const src = firstAudioElement.getAttribute(\"src\");\n                            if (!src) {\n                                continue;\n                            }\n\n                            const link = new Link();\n                            link.Href = path.join(spineLink.MediaOverlays.SmilPathInZip, \"..\", src).replace(/\\\\/g, \"/\");\n                            link.TypeLink = \"audio/?\";\n                            if (audioPublication.Resources) {\n                                const resAudioIndex = audioPublication.Resources.findIndex((l) => {\n                                    // return l.Href === src; // cannot assume SMIL in same folder as root publication manifest\n                                    return l.Href === path.join(spineLink.MediaOverlays!.SmilPathInZip!, \"..\", src).replace(/\\\\/g, \"/\");\n                                });\n                                if (resAudioIndex >= 0) {\n                                    const resAudio = audioPublication.Resources[resAudioIndex];\n                                    if (resAudio.TypeLink) {\n                                        link.TypeLink = resAudio.TypeLink;\n                                    }\n                                    // we assume once inserted in spine, not needed in resources anymore\n                                    audioPublication.Resources.splice(resAudioIndex, 1);\n                                } else {\n                                    const resAudio = audioPublication.Spine.find((l) => {\n                                        return l.Href === link.Href;\n                                    });\n                                    if (resAudio?.TypeLink) {\n                                        link.TypeLink = resAudio.TypeLink;\n                                    }\n                                }\n                            }\n                            if (spineLink.MediaOverlays.duration) {\n                                link.Duration = spineLink.MediaOverlays.duration;\n                            }\n                            audioPublication.Spine.push(link);\n                        }\n                    }\n                    return audioPublication;\n                };\n\n                try {\n                    const audioPublication = await transformPublicationToAudioBook(publication);\n                    const jsonObjAudio = TaJsonSerialize(audioPublication);\n                    const jsonStrAudio = global.JSON.stringify(jsonObjAudio, null, \"  \");\n                    if (!generateDaisyAudioManifestOnly) {\n                        (zipfile as ZipFile).addBuffer(Buffer.from(jsonStrAudio), \"manifest-audio.json\");\n                    } else {\n                        const outputManifestPath = path.join(outputDirPath, generateDaisyAudioManifestOnly + \"_manifest.json\");\n                        ensureDirs(outputManifestPath);\n                        fs.writeFileSync(outputManifestPath, jsonStrAudio, \"utf8\");\n                        debug(\"generateDaisyAudioManifestOnly OK: \" + outputManifestPath);\n                        resolve(outputManifestPath);\n                    }\n                } catch (ero) {\n                    debug(ero);\n                }\n            }\n        } catch (erreur) {\n            debug(erreur);\n        } finally {\n            debug(\"DAISY-EPUB-RWPM done.\");\n            if (!generateDaisyAudioManifestOnly) {\n                timeoutId = setTimeout(() => {\n                    timeoutId = undefined;\n                    reject(\"YAZL zip took too long!? \" + outputZipPath);\n                }, 10000);\n                (zipfile as ZipFile).end();\n            }\n        }\n    });\n};\n\n// TODO: DTBOOK to XHTML XSLT?\n/*\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--******************************\nDAISY XSL TRANSFORM\n\nMake an XSL capable browser\nunderstand DAISY markup.\n****************************** -->\n\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\nxmlns:dtb=\"http://www.daisy.org/z3986/2005/dtbook/\">\n\n<xsl:output method=\"html\" indent=\"no\"/>\n\n<!--******************************\nDOCBOOK, HEAD, META, LINK, BOOK\n*******************************-->\n\n<!-- docbook translates to html -->\n<xsl:template match=\"dtb:dtbook\">\n<html><xsl:apply-templates/></html>\n</xsl:template>\n\n<!-- head maps directly -->\n<xsl:template match=\"dtb:head\">\n<xsl:element name=\"head\">\n<xsl:if test=\"@profile\">\n<xsl:attribute name=\"profile\"><xsl:value-of select=\"@profile\"/></xsl:attribute>\n</xsl:if>\n\n<title><xsl:value-of select=\"/dtb:dtbook/dtb:book/dtb:frontmatter/dtb:doctitle\"/></title>\n\n<link rel=\"stylesheet\" type=\"text/css\" href=\"html.css\" />\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- meta maps directly\nInclude: content\nIf applicable, include: http-equiv, name\nNOTE: meta contains no content so no apply-templates necessary -->\n<xsl:template match=\"dtb:meta\">\n<xsl:element name=\"meta\">\n<xsl:if test=\"@http-equiv\">\n<xsl:attribute name=\"http-equiv\"><xsl:value-of select=\"@http-equiv\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@name\">\n<xsl:attribute name=\"name\"><xsl:value-of select=\"@name\"/></xsl:attribute>\n</xsl:if>\n<xsl:attribute name=\"content\"><xsl:value-of select=\"@content\"/></xsl:attribute>\n</xsl:element>\n</xsl:template>\n\n<!-- link maps directly\nIf aqpplicable, includes: charset, href, hreflang, media, rel, rev, type\nNOTE: link contains no content so no apply-templates necessary -->\n<xsl:template match=\"dtb:link\">\n<xsl:element name=\"link\">\n<xsl:call-template name=\"link-attributes\"/>\n<xsl:if test=\"@media\">\n<xsl:attribute name=\"media\"><xsl:value-of select=\"@media\"/></xsl:attribute>\n</xsl:if>\n</xsl:element>\n</xsl:template>\n\n<!-- book should be translated to body -->\n<xsl:template match=\"dtb:book\">\n<body>\n<xsl:call-template name=\"segmentedNav\"/>\n<xsl:apply-templates/>\n<xsl:call-template name=\"segmentedNav\"/>\n</body>\n</xsl:template>\n\n<!-- inter-DTBook navigation -->\n<xsl:template name=\"segmentedNav\">\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel!='']\">\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel='start']\">\n<xsl:variable name=\"sn\" select=\"/dtb:dtbook/dtb:head/dtb:link[@rel='start']\"/>\n<xsl:element name=\"a\">\n<xsl:attribute name=\"href\">\n<xsl:choose>\n<xsl:when test=\"$sn/@href\"><xsl:value-of select=\"$sn/@href\"/></xsl:when>\n<xsl:otherwise><xsl:value-of select=\"$sn/@resource\"/></xsl:otherwise>\n</xsl:choose>\n</xsl:attribute>\n<xsl:text>Start</xsl:text>\n</xsl:element>\n</xsl:if>\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel='prev']\">\n<xsl:variable name=\"pn\" select=\"/dtb:dtbook/dtb:head/dtb:link[@rel='prev']\"/>\n<xsl:text> | </xsl:text>\n<xsl:element name=\"a\">\n<xsl:attribute name=\"href\">\n<xsl:choose>\n<xsl:when test=\"$pn/@href\"><xsl:value-of select=\"$pn/@href\"/></xsl:when>\n<xsl:otherwise><xsl:value-of select=\"$pn/@resource\"/></xsl:otherwise>\n</xsl:choose>\n</xsl:attribute>\n<xsl:text>Previous</xsl:text>\n</xsl:element>\n</xsl:if>\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel='next']\">\n<xsl:variable name=\"nn\" select=\"/dtb:dtbook/dtb:head/dtb:link[@rel='next']\"/>\n<xsl:text> | </xsl:text>\n<xsl:element name=\"a\">\n<xsl:attribute name=\"href\">\n<xsl:choose>\n<xsl:when test=\"$nn/@href\"><xsl:value-of select=\"$nn/@href\"/></xsl:when>\n<xsl:otherwise><xsl:value-of select=\"$nn/@resource\"/></xsl:otherwise>\n</xsl:choose>\n</xsl:attribute>\n<xsl:text>Next</xsl:text>\n</xsl:element>\n</xsl:if>\n</xsl:if>\n</xsl:template>\n\n<!--*******************************\nFRONTMATTER, BODYMATTER, REARMATTER\n******************************* -->\n\n<!--frontmatter, bodymatter and rearmatter become divisions with appropriate class attributes-->\n<xsl:template match=\"dtb:frontmatter | dtb:bodymatter | dtb:rearmatter\">\n<xsl:element name=\"div\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--**************************\nDOCTITLE, DOCAUTHOR, COVERTITLE\n***************************-->\n\n<!-- doctitle is h1 with class for styling -->\n<xsl:template match=\"dtb:doctitle\">\n<h1 class=\"doctitle\"><xsl:apply-templates/></h1>\n</xsl:template>\n\n<!-- docauthor is p with class for styling -->\n<xsl:template match=\"dtb:docauthor\">\n<p class=\"docauthor\"><xsl:apply-templates/></p>\n</xsl:template>\n\n<!-- covertitle is p with class for styling -->\n<xsl:template match=\"dtb:covertitle\">\n<p class=\"covertitle\"><xsl:apply-templates/></p>\n</xsl:template>\n\n<!--***********************\nLEVELS\n************************-->\n\n<!-- Levels map to div with class -->\n<xsl:template match=\"dtb:level | dtb:level1 | dtb:level2 | dtb:level3 | dtb:level4 | dtb:level5 | dtb:level6\">\n<xsl:element name=\"div\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--***********************\nHEADINGS\n************************-->\n\n<!--h1...h6 map directly -->\n<xsl:template match=\"dtb:h1 | dtb:h2 | dtb:h3 | dtb:h4 | dtb:h5 | dtb:h6\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!-- hd as child of level converts to h1...h6 based on number of level ancestors\nIf more than 6 ancestors then defaults to h6, flattening hierarchy beyond level 6 -->\n<xsl:template match=\"dtb:level/dtb:hd\">\n<xsl:variable name=\"levelDepth\" select=\"count(ancestor-or-self::dtb:level)\" />\n<xsl:choose>\n<xsl:when test=\"$levelDepth &lt;= 6\">\n<xsl:element name=\"{concat('h',$levelDepth)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:when>\n<xsl:otherwise>\n<xsl:element name=\"h6\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\n\n<!--for hd within items like list use paragraph with class -->\n<!-- for bridgehead use paragraph with class -->\n<xsl:template match=\"dtb:hd | dtb:bridgehead\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nPAGENUM, LINENUM\n************************-->\n\n<!--Put the pagenum into a paragraph element if the parent is level or level1...level6 otherwise put it into a span\nUse the pagenum class for formatting -->\n<xsl:template match=\"dtb:pagenum\">\n<xsl:choose>\n<xsl:when test=\"parent::dtb:level or parent::dtb:level1 or parent::dtb:level2 or\nparent::dtb:level3 or parent::dtb:level4 or parent::dtb:level5 or parent::dtb:level6\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:when>\n<xsl:otherwise>\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\n\n<!-- linenum is translated to span with class -->\n<xsl:template match=\"dtb:linenum\">\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nGENERAL BLOCKS\n************************-->\n\n<!-- address, div, p map directly -->\n<xsl:template match=\"dtb:address | dtb:div | dtb:p\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!-- annotation, epigraph, linegroup, note, poem, prodnote, sidebar map to div with class\nFor prodnote, sidebar: Exclude: render attribute, no way to express -->\n<xsl:template\nmatch=\"dtb:annotation | dtb:epigraph | dtb:linegroup | dtb:note | dtb:poem | dtb:prodnote | dtb:sidebar\">\n<xsl:element name=\"div\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!-- blockquote maps directly\nIf applicable, include: cite -->\n<xsl:template match=\"dtb:blockquote\">\n<xsl:element name=\"blockquote\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:if test=\"@cite\">\n<xsl:attribute name=\"cite\"><xsl:value-of select=\"@cite\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- byline, dateline, line maps to a p with class -->\n<xsl:template match=\"dtb:byline | dtb:dateline | dtb:line\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nGENERAL INLINES\n************************-->\n\n<!-- a maps directly\nIf applicable, include: charset, href, hreflang, rel, rev, type\nIf external is true then target a new window -->\n<xsl:template match=\"dtb:a\">\n<xsl:element name=\"a\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"link-attributes\"/>\n<xsl:if test=\"@external='true'\">\n<xsl:attribute name=\"target\">_blank</xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- bdo maps directly,\nInclude: dir -->\n<xsl:template match=\"dtb:bdo\">\n<bdo dir=\"{@dir}\"><xsl:apply-templates/></bdo>\n</xsl:template>\n\n<!-- abbr, acronym, cite, dfn, em, kbd, samp, strong, sub, sup map directly -->\n<xsl:template\nmatch=\"dtb:abbr | dtb:acronym | dtb:cite | dtb:dfn | dtb:em | dtb:kbd | dtb:samp | dtb:strong | dtb:sub | dtb:sup\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- code maps directly\nIf has class preserve-whitespace then surround with a pre tag -->\n<xsl:template match=\"dtb:code\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:choose>\n<xsl:when test=\"@class='preserve-whitespace'\">\n<xsl:element name=\"pre\"><xsl:apply-templates/></xsl:element>\n</xsl:when>\n<xsl:otherwise>\n<xsl:apply-templates/>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:element>\n</xsl:template>\n\n<!-- span maps to span for classes underline, strikethrough,\ndouble-strikethrough, small-caps, but is omitted otherwise -->\n<xsl:template match=\"dtb:span\">\n<xsl:choose>\n<xsl:when test=\"@class='underline'\">\n<span class=\"underline\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:when test=\"@class='strikethrough'\">\n<span class=\"strikethrough\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:when test=\"@class='double-strikethrough'\">\n<span class=\"double-strikethrough\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:when test=\"@class='small-caps'\">\n<span class=\"small-caps\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:otherwise>\n<xsl:apply-templates/>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\n\n<!--title-->\n\n<!-- author maps to p with class -->\n<xsl:template match=\"dtb:author\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\"/></xsl:attribute>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- br maps directly\nNOTE: no apply-templates needed since this tag is always self closing-->\n<xsl:template match=\"dtb:br\">\n<br />\n</xsl:template>\n\n<!-- q maps directly\nIf applicable, includes: cite -->\n<xsl:template match=\"dtb:q\">\n<xsl:element name=\"q\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:if test=\"@cite\">\n<xsl:attribute name=\"cite\"><xsl:value-of select=\"@cite\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- annoref, noteref maps to span with class -->\n<xsl:template match=\"dtb:annoref | dtb:noteref\">\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n</xsl:element>\n</xsl:template>\n\n<!-- sent, w have no equivalent tag -->\n<xsl:template match=\"dtb:sent | dtb:w\">\n<xsl:apply-templates/>\n</xsl:template>\n\n<!--*************************\nLISTS\n************************-->\n\n<!--Get fancy with the various list types-->\n\n<!-- An unordered list will be wrapped in ul tags -->\n<xsl:template match=\"dtb:list[@type='ul']\">\n<xsl:element name=\"ul\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- A preformatted list will be wrapped in ul tags with an appropriate class.\nCSS can be used to turn off default display symbols, the list will still be\nrendered as such in the browser's DOM, which will let screen readers\nannounce the item as a list -->\n<xsl:template match=\"dtb:list[@type='pl']\">\n<xsl:element name=\"ul\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\">pl</xsl:attribute>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- An ordered list will be wrapped in ol tags\nEnsure the desired formatting is preserved by pushing the enum attribute into the class attribute\nNote: replaces enum=\"1\" with class=\"one\" to ensure CSS 2.1 validation\nIf applicable, include: start -->\n<xsl:template match=\"dtb:list[@type='ol']\">\n<xsl:element name=\"ol\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:choose>\n<xsl:when test=\"@enum='1'\">\n<xsl:attribute name=\"class\">one</xsl:attribute>\n</xsl:when>\n<xsl:otherwise>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"@enum\"/></xsl:attribute>\n</xsl:otherwise>\n</xsl:choose>\n<xsl:if test=\"@start\">\n<xsl:attribute name=\"start\"><xsl:value-of select=\"@start\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- li maps directly -->\n<xsl:template match=\"dtb:li\">\n<xsl:element name=\"li\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- lic maps to span -->\n<xsl:template match=\"dtb:lic\">\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\"/></xsl:attribute>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- *************************\nDEFINITION LIST\n************************ -->\n\n<!-- dd, dl, dt map directly -->\n<xsl:template match=\"dtb:dd | dtb:dl | dtb:dt\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nTABLES\n************************ *** -->\n\n<!-- table maps directly\nIf applicable, include: border, cellpadding, cellspacing, frame, rules, summary, width -->\n<xsl:template match=\"dtb:table\">\n<xsl:element name=\"table\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:if test=\"@border\">\n<xsl:attribute name=\"border\"><xsl:value-of select=\"@border\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@cellpadding\">\n<xsl:attribute name=\"cellpadding\"><xsl:value-of select=\"@cellpadding\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@cellspacing\">\n<xsl:attribute name=\"cellspacing\"><xsl:value-of select=\"@cellspacing\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@frame\">\n<xsl:attribute name=\"frame\"><xsl:value-of select=\"@frame\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rules\">\n<xsl:attribute name=\"rules\"><xsl:value-of select=\"@rules\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@summary\">\n<xsl:attribute name=\"summary\"><xsl:value-of select=\"@summary\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@width\">\n<xsl:attribute name=\"width\"><xsl:value-of select=\"@width\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- table/caption maps directly -->\n<xsl:template match=\"dtb:table/dtb:caption\">\n<xsl:element name=\"caption\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- tr maps directly\nIf applicable, include: align, char, charoff, valign -->\n<xsl:template match=\"dtb:tr\">\n<xsl:element name=\"tr\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- col, colgroup map directly\nIf applicable, include: align, char, charoff, span, valign, width -->\n<xsl:template match=\"dtb:col | dtb:colgroup\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:if test=\"@span\">\n<xsl:attribute name=\"span\"><xsl:value-of select=\"@span\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@width\">\n<xsl:attribute name=\"width\"><xsl:value-of select=\"@width\"/></xsl:attribute>\n</xsl:if>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- tbody, thead, tfoot map directly\nIf applicable, include: align, char, charoff, valign -->\n<xsl:template match=\"dtb:tbody | dtb:thead | dtb:tfoot\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- td, th map directly\nIf applicable, include: abbr, align, axis, char, charoff, colspan, headers, rowspan, scope, valign -->\n<xsl:template match=\"dtb:td | dtb:th\">\n<xsl:element name=\"td\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:if test=\"@abbr\">\n<xsl:attribute name=\"abbr\"><xsl:value-of select=\"@abbr\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@axis\">\n<xsl:attribute name=\"axis\"><xsl:value-of select=\"@axis\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@colspan\">\n<xsl:attribute name=\"colspan\"><xsl:value-of select=\"@colspan\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@headers\">\n<xsl:attribute name=\"headers\"><xsl:value-of select=\"@headers\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rowspan\">\n<xsl:attribute name=\"rowspan\"><xsl:value-of select=\"@rowspan\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@scope\">\n<xsl:attribute name=\"scope\"><xsl:value-of select=\"@scope\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nIMAGES\n************************ *** -->\n\n<!-- img maps directly\nInclude: alt, src\nIf applicable, include: longdesc, height, width\nNOTE: img is self closing so no apply-templates necessary -->\n<xsl:template match=\"dtb:img\">\n<xsl:element name=\"img\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"alt\"><xsl:value-of select=\"@alt\"/></xsl:attribute>\n<xsl:attribute name=\"src\"><xsl:value-of select=\"@src\"/></xsl:attribute>\n<xsl:if test=\"@longdesc\">\n<xsl:attribute name=\"longdesc\"><xsl:value-of select=\"@longdesc\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@height\">\n<xsl:attribute name=\"height\"><xsl:value-of select=\"@height\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@width\">\n<xsl:attribute name=\"width\"><xsl:value-of select=\"@width\"/></xsl:attribute>\n</xsl:if>\n</xsl:element>\n</xsl:template>\n\n<!-- imggroup maps to div with class -->\n<xsl:template match=\"dtb:imggroup\">\n<div class=\"imggroup\"><xsl:apply-templates/></div>\n</xsl:template>\n\n<!-- imggroup/caption maps to div with class\nExcludes imgref - no way to express -->\n<xsl:template match=\"dtb:imggroup/dtb:caption\">\n<div class=\"caption\"><xsl:apply-templates/></div>\n</xsl:template>\n\n<!--*************************\nHelpers\n************************ *** -->\n\n<!-- If applicable include id -->\n<xsl:template name=\"base-attributes\">\n<xsl:if test=\"@id\">\n<xsl:attribute name=\"id\"><xsl:value-of select=\"@id\"/></xsl:attribute>\n</xsl:if>\n</xsl:template>\n\n<!-- If applicable include align, char, charoff, valign -->\n<xsl:template name=\"alignment-attributes\">\n<xsl:if test=\"@align\">\n<xsl:attribute name=\"align\"><xsl:value-of select=\"@align\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@char\">\n<xsl:attribute name=\"char\"><xsl:value-of select=\"@char\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@charoff\">\n<xsl:attribute name=\"charoff\"><xsl:value-of select=\"@charoff\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@valign\">\n<xsl:attribute name=\"valign\"><xsl:value-of select=\"@valign\"/></xsl:attribute>\n</xsl:if>\n</xsl:template>\n\n<!-- If applicable include: charset, href, hreflang, rel, rev, type -->\n<xsl:template name=\"link-attributes\">\n<xsl:if test=\"@charset\">\n<xsl:attribute name=\"charset\"><xsl:value-of select=\"@charset\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@href\">\n<xsl:attribute name=\"href\"><xsl:value-of select=\"@href\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@hreflang\">\n<xsl:attribute name=\"hreflang\"><xsl:value-of select=\"@hreflang\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rel\">\n<xsl:attribute name=\"rel\"><xsl:value-of select=\"@rel\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rev\">\n<xsl:attribute name=\"rev\"><xsl:value-of select=\"@rev\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@type\">\n<xsl:attribute name=\"type\"><xsl:value-of select=\"@type\"/></xsl:attribute>\n</xsl:if>\n</xsl:template>\n\n</xsl:stylesheet>\n*/\n"]}