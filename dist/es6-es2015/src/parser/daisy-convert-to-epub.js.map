{"version":3,"file":"daisy-convert-to-epub.js","sourceRoot":"","sources":["../../../../src/parser/daisy-convert-to-epub.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as xmldom from \"xmldom\";\nimport * as xpath from \"xpath\";\nimport { ZipFile } from \"yazl\";\n\nimport { MediaOverlayNode } from \"@models/media-overlay\";\nimport { Metadata } from \"@models/metadata\";\nimport { Properties } from \"@models/metadata-properties\";\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { TaJsonDeserialize, TaJsonSerialize } from \"@r2-lcp-js/serializable\";\nimport { IZip } from \"@r2-utils-js/_utils/zip/zip\";\n\nimport { lazyLoadMediaOverlays } from \"./epub\";\nimport { loadFileBufferFromZipPath, loadFileStrFromZipPath } from \"./epub-daisy-common\";\n\nconst debug = debug_(\"r2:shared#parser/daisy-convert-to-epub\");\n\nfunction ensureDirs(fspath: string) {\n    const dirname = path.dirname(fspath);\n\n    if (!fs.existsSync(dirname)) {\n        ensureDirs(dirname);\n        fs.mkdirSync(dirname);\n    }\n}\n\n// this function modifies the input parameter \"publication\"!\nexport const convertDaisyToReadiumWebPub = async (\n    outputDirPath: string, publication: Publication): Promise<string | undefined> => {\n\n    return new Promise(async (resolve, reject) => {\n\n        const zipInternal = publication.findFromInternal(\"zip\");\n        if (!zipInternal) {\n            debug(\"No publication zip!?\");\n            return reject(\"No publication zip!?\");\n        }\n        const zip = zipInternal.Value as IZip;\n\n        const outputZipPath = path.join(outputDirPath, \"daisy-to-epub.webpub\");\n        ensureDirs(outputZipPath);\n\n        let timeoutId: NodeJS.Timeout | undefined;\n        const zipfile = new ZipFile();\n        try {\n            const writeStream = fs.createWriteStream(outputZipPath);\n            zipfile.outputStream.pipe(writeStream)\n                .on(\"close\", () => {\n                    debug(\"ZIP close\");\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                        timeoutId = undefined;\n                        resolve(outputZipPath);\n                    }\n                })\n                .on(\"error\", (e: any) => {\n                    debug(\"ZIP error\", e);\n                    reject(e);\n                });\n\n            // <dtbook xmlns=\"http://www.daisy.org/z3986/2005/dtbook/\" ...\n            const select = xpath.useNamespaces({\n                dtbook: \"http://www.daisy.org/z3986/2005/dtbook/\",\n                // epub: \"http://www.idpf.org/2007/ops\",\n                // xhtml: \"http://www.w3.org/1999/xhtml\",\n            });\n\n            const elementNames = [\n                \"address\",\n                \"annoref\",\n                \"annotation\",\n                \"author\",\n                \"bdo\",\n                \"bodymatter\",\n                \"book\",\n                \"bridgehead\",\n                \"byline\",\n                \"caption\",\n                \"cite\",\n                \"col\",\n                \"colgroup\",\n                \"covertitle\",\n                \"dateline\",\n                \"dfn\",\n                \"docauthor\",\n                \"doctitle\",\n                \"dtbook\",\n                \"epigraph\",\n                \"frontmatter\",\n                \"hd\",\n                \"imggroup\",\n                \"kbd\",\n                \"level\",\n                \"levelhd\",\n                \"level1\",\n                \"level2\",\n                \"level3\",\n                \"level4\",\n                \"level5\",\n                \"level6\",\n                \"lic\",\n                \"line\",\n                \"linegroup\",\n                \"linenum\",\n                \"link\",\n                \"list\",\n                \"note\",\n                \"noteref\",\n                \"pagenum\",\n                \"poem\",\n                \"prodnote\",\n                \"rearmatter\",\n                \"samp\",\n                \"sent\",\n                \"sub\",\n                \"sup\",\n                \"q\",\n                \"w\",\n                \"notice\",\n                \"sidebar\",\n                \"blockquote\",\n                \"abbr\",\n                \"acronym\",\n                \"title\",\n            ];\n\n            let combinedMediaOverlays: MediaOverlayNode | undefined;\n\n            const patchMediaOverlaysTextHref = (mo: MediaOverlayNode) => {\n\n                if (mo.Text) {\n                    // TODO: .xml file extension replacement is bit weak / brittle\n                    // (but for most DAISY books, this is a reasonable expectation)\n                    mo.Text = mo.Text.replace(/\\.xml/, \".xhtml\");\n                }\n                if (mo.Children) {\n                    for (const child of mo.Children) {\n                        patchMediaOverlaysTextHref(child);\n                    }\n                }\n            };\n\n            // dtb:multimediaContent ==> audio,text\n            if (publication.Spine &&\n                publication.Metadata?.AdditionalJSON &&\n                publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioFullText\") {\n\n                combinedMediaOverlays = new MediaOverlayNode();\n                combinedMediaOverlays.SmilPathInZip = undefined;\n                combinedMediaOverlays.initialized = true;\n                combinedMediaOverlays.Role = [];\n                combinedMediaOverlays.Role.push(\"section\");\n                combinedMediaOverlays.duration = 0;\n\n                for (const linkItem of publication.Spine) {\n                    if (linkItem.MediaOverlays) {\n\n                        if (!linkItem.MediaOverlays.initialized) {\n                            // mo.initialized true/false is automatically handled\n                            await lazyLoadMediaOverlays(publication, linkItem.MediaOverlays);\n\n                            if (linkItem.MediaOverlays.duration) {\n                                if (!linkItem.Duration) {\n                                    linkItem.Duration = linkItem.MediaOverlays.duration;\n                                }\n                                if (linkItem.Alternate) {\n                                    for (const altLink of linkItem.Alternate) {\n                                        if (altLink.TypeLink === \"application/vnd.syncnarr+json\") {\n                                            if (!altLink.Duration) {\n                                                altLink.Duration = linkItem.MediaOverlays.duration;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (linkItem.MediaOverlays.Children) {\n                            if (!combinedMediaOverlays.Children) {\n                                combinedMediaOverlays.Children = [];\n                            }\n                            combinedMediaOverlays.Children =\n                                combinedMediaOverlays.Children.concat(linkItem.MediaOverlays.Children);\n\n                            if (linkItem.MediaOverlays.duration) {\n                                combinedMediaOverlays.duration += linkItem.MediaOverlays.duration;\n                            }\n                        }\n                    }\n                }\n\n                patchMediaOverlaysTextHref(combinedMediaOverlays);\n            }\n            publication.Spine = [];\n\n            const resourcesToKeep: Link[] = [];\n\n            // reference copy! (not by value) so we can publication.Resources.push(...) safely within the loop\n            // const resources = [...publication.Resources];\n            // ... but we completely replace the array of Links, so this is fine:\n            for (const resLink of publication.Resources) {\n                // relative to publication root (package.opf / ReadiumWebPubManifest.json)\n                if (!resLink.HrefDecoded) {\n                    continue;\n                }\n                if (resLink.TypeLink === \"text/css\" || resLink.HrefDecoded.endsWith(\".css\")) {\n\n                    let cssText = await loadFileStrFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    if (!cssText) {\n                        debug(\"!loadFileStrFromZipPath\", resLink.HrefDecoded);\n                        continue;\n                    }\n\n                    // replace comments\n                    cssText = cssText.replace(/\\/\\*([\\s\\S]+?)\\*\\//gm, (_match, p1, _offset, _string) => {\n                        const base64 = Buffer.from(p1).toString(\"base64\");\n                        return `/*__${base64}__*/`;\n                    });\n\n                    // const regex = new RegExp(`[^#\\.](${elementNames.join(\"|\")})`, \"g\");\n                    for (const elementName of elementNames) {\n                        // meant to patch CSS selectors, but not property values\n                        const regex = new RegExp(\n                            `([^#\\.a-zA-Z0-9\\-_])(${elementName})([^a-zA-Z0-9\\-_;])`, \"g\");\n                        // let i = -1;\n                        // let match: RegExpExecArray | null;\n                        // // tslint:disable-next-line: no-conditional-assignment\n                        // while (match = regex.exec(cssText)) {\n                        //     i++;\n                        //     debug(\"A -----------\");\n                        //     debug(i, elementName, `$_$_$${match[0]}$_$_$`,\n                        // `===${match[1]}^^^${match[2]}^^^${match[3]}===`);\n                        //     debug(\"B -----------\");\n                        // }\n                        cssText = cssText.replace(regex, `$1.$2_R2$3`);\n\n                        // second pass, as the first doesn't match tokens with trailing / leading separators\n                        cssText = cssText.replace(regex, `$1.$2_R2$3`);\n                    }\n\n                    // restore comments\n                    cssText = cssText.replace(/\\/\\*__([\\s\\S]+?)__\\*\\//g, (_match, p1, _offset, _string) => {\n                        const comment = Buffer.from(p1, \"base64\").toString(\"utf8\");\n                        return `/*${comment}*/`;\n                    });\n\n                    // const newCssFilePath = resLink.HrefDecoded.replace(/\\.css$/, \"__.css\");\n                    // const cssOutputFilePath = path.join(outputDirPathExploded, newCssFilePath);\n                    // ensureDirs(cssOutputFilePath);\n                    // fs.writeFileSync(cssOutputFilePath, cssText);\n                    zipfile.addBuffer(Buffer.from(cssText), resLink.HrefDecoded);\n\n                    // const resLinkJson = TaJsonSerialize(resLink);\n                    // // resLinkJson.href = newCssFilePath;\n                    // const resLinkClone = TaJsonDeserialize<Link>(resLinkJson, Link);\n                    // resLinkClone.setHrefDecoded(newCssFilePath);\n\n                    resourcesToKeep.push(resLink);\n\n                } else if (resLink.TypeLink === \"application/x-dtbook+xml\" || resLink.HrefDecoded.endsWith(\".xml\")) {\n\n                    const dtBookStr = await loadFileStrFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    if (!dtBookStr) {\n                        debug(\"!loadFileStrFromZipPath\", dtBookStr);\n                        continue;\n                    }\n                    const dtBookDoc = new xmldom.DOMParser().parseFromString(dtBookStr, \"application/xml\");\n\n                    const title = dtBookDoc.getElementsByTagName(\"doctitle\")[0].textContent;\n\n                    const listElements = dtBookDoc.getElementsByTagName(\"list\");\n                    for (let i = 0; i < listElements.length; i++) {\n                        const listElement = listElements.item(i);\n                        if (!listElement) {\n                            continue;\n                        }\n                        const type = listElement.getAttribute(\"type\");\n                        if (type) {\n                            // TODO: strictly-speaking, this is a read-only property!\n                            (listElement as any).tagName = type;\n                            // listElement.removeAttribute(\"type\");\n                        }\n                    }\n\n                    //             .replace(/(<\\/?)imggroup/g, \"$1figure\")\n                    //             .replace(/<caption/g, \"<figcaption\")\n                    //             .replace(/<\\/caption>/g, \"</figcaption>\");\n\n                    for (const elementName of elementNames) {\n                        // getElementsByName(elementName: string): NodeListOf<HTMLElement>\n                        // ==> not available in the XMLDOM API\n                        // getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>\n                        // ==> mutates during loop because of tagName reassignment!\n                        const els = Array.from(dtBookDoc.getElementsByTagName(elementName)).filter((el) => el);\n                        for (const el of els) {\n                            el.setAttribute(\"data-dtbook\", elementName);\n                            const cls = el.getAttribute(\"class\");\n                            el.setAttribute(\"class\", `${cls ? (cls + \" \") : \"\"}${elementName}_R2`);\n                            // TODO: strictly-speaking, this is a read-only property!\n                            (el as any).tagName =\n                                ((elementName === \"dtbook\") ? \"html\" :\n                                    ((elementName === \"book\") ? \"body\" :\n                                        ((elementName === \"pagenum\") ? \"span\" :\n                                            ((elementName === \"sent\") ? \"span\" :\n                                                ((elementName === \"caption\") ? \"figcaption\" :\n                                                    ((elementName === \"imggroup\") ? \"figure\" :\n                                                        \"div\"))))));\n                        }\n                    }\n\n                    // <?xml-stylesheet type=\"text/css\" href=\"dtbookbasic.css\"?>\n                    const stylesheets =\n                        select(\"/processing-instruction('xml-stylesheet')\", dtBookDoc) as ProcessingInstruction[];\n                    const cssHrefs: string[] = []; // `<link rel=\"stylesheet\" href=\"${cssHref}\" />`\n                    for (const stylesheet of stylesheets) {\n                        if (!stylesheet.nodeValue) {\n                            continue;\n                        }\n                        if (!stylesheet.nodeValue.includes(\"text/css\")) {\n                            continue;\n                        }\n                        const match = stylesheet.nodeValue.match(/href=(\"|')(.*?)(\"|')/);\n                        if (!match) {\n                            continue;\n                        }\n                        const href = match[2].trim();\n                        if (href) {\n                            cssHrefs.push(href);\n                        }\n                    }\n\n                    const smilRefs = select(\"//*[@smilref]\", dtBookDoc) as Element[];\n                    for (const smilRef of smilRefs) {\n                        const ref = smilRef.getAttribute(\"smilref\");\n                        if (ref) {\n                            smilRef.setAttribute(\"data-smilref\", ref);\n                        }\n                        smilRef.removeAttribute(\"smilref\");\n                    }\n\n                    // does not work (element renamed via the tagName assignment still have the original NameSpaceURI,\n                    // which gets serialized)\n                    // dtBookDoc.documentElement.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n\n                    // does not work (read only property):\n                    // (dtBookDoc as any).doctype = null;\n                    // ...so we use regexp replace below\n\n                    const dtbookNowXHTML = new xmldom.XMLSerializer().serializeToString(dtBookDoc)\n                        .replace(/xmlns=\"http:\\/\\/www\\.daisy\\.org\\/z3986\\/2005\\/dtbook\\/\"/, \"xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\")\n                        .replace(/^([\\s\\S]*)<html/gm,\n                            `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE xhtml>\n<html`)\n                        .replace(/<head([\\s\\S]*?)>/gm,\n                            `\n<head$1>\n<meta charset=\"UTF-8\" />\n<title>${title}</title>\n`)\n                        .replace(/<\\/head[\\s\\S]*?>/gm,\n                            `\n${cssHrefs.reduce((pv, cv) => {\n                                return pv + \"\\n\" + `<link rel=\"stylesheet\" type=\"text/css\" href=\"${cv}\" />`;\n                            }, \"\")}\n</head>\n`);\n                    const xhtmlFilePath = resLink.HrefDecoded.replace(/\\.(.+)$/, \".xhtml\");\n\n                    // const xhtmlOutputFilePath = path.join(outputDirPathExploded, xhtmlFilePath);\n                    // ensureDirs(xhtmlOutputFilePath);\n                    // fs.writeFileSync(xhtmlOutputFilePath, dtbookNowXHTML);\n                    // zipfile.addFile(xhtmlOutputFilePath, xhtmlFilePath);\n                    zipfile.addBuffer(Buffer.from(dtbookNowXHTML), xhtmlFilePath);\n\n                    const resLinkJson = TaJsonSerialize(resLink);\n                    // resLinkJson.href = xhtmlFilePath;\n                    const resLinkClone = TaJsonDeserialize<Link>(resLinkJson, Link);\n                    resLinkClone.setHrefDecoded(xhtmlFilePath);\n                    resLinkClone.TypeLink = \"application/xhtml+xml\";\n\n                    publication.Spine.push(resLinkClone);\n\n                    if (combinedMediaOverlays && publication.Spine.length === 1) {\n                        resLinkClone.MediaOverlays = combinedMediaOverlays;\n\n                        if (combinedMediaOverlays.duration) {\n                            resLinkClone.Duration = combinedMediaOverlays.duration;\n                        }\n\n                        const moURL = \"smil-media-overlays.json\";\n                        // mediaOverlayURLPath + \"?\" +\n                        //     mediaOverlayURLParam + \"=\" +\n                        //     encodeURIComponent_RFC3986(\n                        //         resLinkClone.HrefDecoded ? resLinkClone.HrefDecoded : resLinkClone.Href);\n\n                        // legacy method:\n                        if (!resLinkClone.Properties) {\n                            resLinkClone.Properties = new Properties();\n                        }\n                        resLinkClone.Properties.MediaOverlay = moURL;\n\n                        // new method:\n                        // https://w3c.github.io/sync-media-pub/incorporating-synchronized-narration.html#with-webpub\n                        if (!resLinkClone.Alternate) {\n                            resLinkClone.Alternate = [];\n                        }\n                        const moLink = new Link();\n                        moLink.Href = moURL;\n                        moLink.TypeLink = \"application/vnd.syncnarr+json\";\n                        moLink.Duration = resLinkClone.Duration;\n                        resLinkClone.Alternate.push(moLink);\n\n                        const jsonObjMO = TaJsonSerialize(combinedMediaOverlays);\n                        const jsonStrMO = global.JSON.stringify(jsonObjMO, null, \"  \");\n                        zipfile.addBuffer(Buffer.from(jsonStrMO), moURL);\n                    }\n\n                } else if (!resLink.HrefDecoded.endsWith(\".opf\") &&\n                    !resLink.HrefDecoded.endsWith(\".res\") &&\n                    !resLink.HrefDecoded.endsWith(\".ncx\")) {\n\n                    const buff = await loadFileBufferFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    if (buff) {\n                        zipfile.addBuffer(buff, resLink.HrefDecoded);\n                    }\n\n                    resourcesToKeep.push(resLink);\n                }\n            }\n\n            publication.Resources = resourcesToKeep;\n\n            if (!publication.Metadata) {\n                publication.Metadata = new Metadata();\n            }\n            // publication.Metadata.Source = \"DAISY\";\n            if (!publication.Metadata.AdditionalJSON) {\n                publication.Metadata.AdditionalJSON = {};\n            }\n            publication.Metadata.AdditionalJSON.ReadiumWebPublicationConvertedFrom = \"DAISY\";\n\n            const findFirstDescendantText = (parent: Element): Element | undefined => {\n                if (parent.childNodes && parent.childNodes.length) {\n                    // tslint:disable-next-line: prefer-for-of\n                    for (let i = 0; i < parent.childNodes.length; i++) {\n                        const child = parent.childNodes[i];\n                        if (child.nodeType === 1) { // Node.ELEMENT_NODE\n                            const element = child as Element;\n                            if (element.localName && element.localName.toLowerCase() === \"text\") {\n                                return element;\n                            }\n                        }\n                    }\n                    // tslint:disable-next-line: prefer-for-of\n                    for (let i = 0; i < parent.childNodes.length; i++) {\n                        const child = parent.childNodes[i];\n                        if (child.nodeType === 1) { // Node.ELEMENT_NODE\n                            const element = child as Element;\n                            const found = findFirstDescendantText(element);\n                            if (found) {\n                                return found;\n                            }\n                        }\n                    }\n                }\n                return undefined;\n            };\n\n            const smilDocs: Record<string, Document> = {};\n\n            const processLink = async (link: Link) => {\n                // relative to publication root (package.opf / ReadiumWebPubManifest.json)\n                let href = link.HrefDecoded;\n                if (!href) {\n                    return;\n                }\n\n                let fragment: string | undefined;\n                if (href.indexOf(\"#\") >= 0) {\n                    const arr = href.split(\"#\");\n                    href = arr[0].trim();\n                    fragment = arr[1].trim();\n                }\n                if (!href) {\n                    return;\n                }\n\n                let smilDoc = smilDocs[href];\n                if (!smilDoc) {\n                    const smilStr = await loadFileStrFromZipPath(href, href, zip);\n                    if (!smilStr) {\n                        debug(\"!loadFileStrFromZipPath\", smilStr);\n                        return;\n                    }\n                    smilDoc = new xmldom.DOMParser().parseFromString(smilStr, \"application/xml\");\n                    smilDocs[href] = smilDoc;\n                }\n\n                let targetEl = fragment ? smilDoc.getElementById(fragment) as Element : undefined;\n                if (!targetEl) {\n                    // const textElems = smilDoc.getElementsByTagName(\"text\");\n                    // if (textElems && textElems[0]) {\n                    //     targetEl = textElems[0];\n                    // }\n                    targetEl = findFirstDescendantText(smilDoc.documentElement);\n                }\n                if (!targetEl) {\n                    return;\n                }\n                if (targetEl.nodeName !== \"text\") {\n                    // const textElems = select(\"//text\", targetEl, true) as Element;\n                    // if (textElems) {\n                    //     targetEl = textElems;\n                    // }\n                    targetEl = findFirstDescendantText(targetEl);\n                }\n                if (!targetEl || targetEl.nodeName !== \"text\") {\n                    return;\n                }\n\n                const src = targetEl.getAttribute(\"src\");\n                if (!src) {\n                    return;\n                }\n                // TODO: path is relative to SMIL (not to publication root),\n                // and .xml file extension replacement is bit weak / brittle\n                // (but for most DAISY books, this is a reasonable expectation)\n                link.Href = src.replace(/\\.xml/, \".xhtml\");\n            };\n\n            const processLinks = async (links: Link[]) => {\n                for (const link of links) {\n                    await processLink(link);\n                    if (link.Children) {\n                        await processLinks(link.Children);\n                    }\n                }\n            };\n\n            if (publication.PageList) {\n                for (const link of publication.PageList) {\n                    await processLink(link);\n                }\n            }\n\n            if (publication.Landmarks) {\n                for (const link of publication.Landmarks) {\n                    await processLink(link);\n                }\n            }\n\n            if (publication.TOC) {\n                await processLinks(publication.TOC);\n            }\n\n            const jsonObj = TaJsonSerialize(publication);\n            const jsonStr = global.JSON.stringify(jsonObj, null, \"  \");\n            zipfile.addBuffer(Buffer.from(jsonStr), \"manifest.json\");\n        } catch (erreur) {\n            debug(erreur);\n        } finally {\n            timeoutId = setTimeout(() => {\n                timeoutId = undefined;\n                reject(\"YAZL zip took too long!? \" + outputZipPath);\n            }, 10000);\n            zipfile.end();\n        }\n    });\n};\n\n// const parseFrontmatterXml = (xmlDom: Document, serializer: xmldom.XMLSerializer, data: string[]) => {\n//     let levelDoms = [];\n//     const frontmatter = xmlDom.getElementsByTagName(\"frontmatter\")[0];\n//     if (frontmatter) {\n//         const docTitle = frontmatter.getElementsByTagName(\"doctitle\")[0];\n//         const docAuthor = frontmatter.getElementsByTagName(\"docauthor\")[0];\n//         const coverTitle = frontmatter.getElementsByTagName(\"covertitle\")[0];\n//         const level1s = Array.from(frontmatter.getElementsByTagName(\"level1\"));\n//         const levels = Array.from(frontmatter.getElementsByTagName(\"level\"));\n\n//         levelDoms = levels.concat(level1s);\n//         if (levelDoms.length > 0) {\n//             levelDoms.forEach((element: Element, i: number) => {\n//                 if (!element.parentNode) {\n//                     return;\n//                 }\n//                 const bodyContent = element.parentNode.cloneNode();\n//                 if (i === 0) {\n//                     if (docTitle) {\n//                         bodyContent.appendChild(docTitle);\n//                     }\n//                     if (docAuthor) {\n//                         bodyContent.appendChild(docAuthor);\n//                     }\n//                     if (coverTitle) {\n//                         bodyContent.appendChild(coverTitle);\n//                     }\n//                 }\n//                 bodyContent.appendChild(element);\n//                 const bodyContentStr = serializer.serializeToString(bodyContent);\n//                 data.push(bodyContentStr);\n//             });\n//         } else {\n//             const bodyContent = frontmatter.cloneNode();\n//             if (docTitle) {\n//                 bodyContent.appendChild(docTitle);\n//             }\n//             if (docAuthor) {\n//                 bodyContent.appendChild(docAuthor);\n//             }\n//             if (coverTitle) {\n//                 bodyContent.appendChild(coverTitle);\n//             }\n//             const bodyContentStr = serializer.serializeToString(bodyContent);\n//             data.push(bodyContentStr);\n//         }\n//     }\n// };\n\n// const parseBodymatterXml = (xmlDom: Document, serializer: xmldom.XMLSerializer, data: string[]) => {\n//     let levelDoms = [];\n//     const bodymatter = xmlDom.getElementsByTagName(\"bodymatter\")[0];\n//     if (bodymatter) {\n//         const level1s = Array.from(bodymatter.getElementsByTagName(\"level1\"));\n//         const levels = Array.from(bodymatter.getElementsByTagName(\"level\"));\n\n//         levelDoms = levels.concat(level1s);\n//         levelDoms.forEach((element) => {\n//             if (!element.parentNode) {\n//                 return;\n//             }\n//             const bodyContent = element.parentNode.cloneNode();\n//             bodyContent.appendChild(element);\n//             const bodyContentStr = serializer.serializeToString(bodyContent);\n//             data.push(bodyContentStr);\n//         });\n//     }\n// };\n\n// const parseRearmatterXml = (xmlDom: Document, serializer: xmldom.XMLSerializer, data: string[]) => {\n//     let levelDoms = [];\n//     const rearmatter = xmlDom.getElementsByTagName(\"rearmatter\")[0];\n//     if (rearmatter) {\n//         const level1s = Array.from(rearmatter.getElementsByTagName(\"level1\"));\n//         const levels = Array.from(rearmatter.getElementsByTagName(\"level\"));\n\n//         levelDoms = levels.concat(level1s);\n//         levelDoms.forEach((element) => {\n//             if (!element.parentNode) {\n//                 return;\n//             }\n//             const bodyContent = element.parentNode.cloneNode();\n//             bodyContent.appendChild(element);\n//             const bodyContentStr = serializer.serializeToString(bodyContent);\n//             data.push(bodyContentStr);\n//         });\n//     }\n// };\n\n// const parseSmilFile = async (zip: IZip, srcDecoded: string, opf: OPF): Promise<SMIL> => {\n//     if (!opf.ZipPath) {\n//         return Promise.reject(\"!opf.ZipPath??\");\n//     }\n//     const smilPath = path.join(path.dirname(opf.ZipPath), srcDecoded)\n//         .replace(/\\\\/g, \"/\");\n//     debug(`>>>>> parseSmilFile ${smilPath}`);\n//     const smilStr = await loadFileStrFromZipPath(smilPath, smilPath, zip);\n//     if (!smilStr) {\n//         return Promise.reject(\"!loadFileStrFromZipPath: \" + smilPath);\n//     }\n//     const smilXmlDoc = new xmldom.DOMParser().parseFromString(smilStr);\n//     return XML.deserialize<SMIL>(smilXmlDoc, SMIL);\n// };\n\n// const getSmilLinkReference = async (\n//     parsedFiles: ParsedFile[], zip: IZip, srcDecoded: string, opf: OPF): Promise<string | undefined> => {\n\n//     const hashLink = srcDecoded.split(\"#\");\n//     const smilLink = hashLink[0];\n//     const smilID = hashLink[1];\n\n//     // const smilFilePath = path.join(filePath, smilLink).replace(/\\\\/g, \"/\");\n\n//     // const smilStr = fs.readFileSync(smilFilePath, { encoding: \"utf8\" });\n//     const smil = await parseSmilFile(zip, smilLink, opf);\n\n//     const linkedPar = findParInSmilWithID(smil, smilID);\n//     if (!linkedPar) {\n//         return undefined;\n//     }\n//     if (linkedPar.Text) {\n//         const hashXmlLink = linkedPar.Text.Src.split(\"#\");\n//         const xmlID = hashXmlLink[1];\n//         const xmlLink = findXhtmlWithID(parsedFiles, xmlID);\n//         return `${xmlLink}#${xmlID}`;\n//         // return linkedPar.Text.Src;\n//     }\n\n//     return undefined;\n// };\n\n// const findXhtmlWithID = (parsedFiles: ParsedFile[], ID: string) => {\n//     for (const parsedFile of parsedFiles) {\n//         // const parsedFile: ParsedFile = publication.ParsedFiles[i];\n//         if (parsedFile.Type === \"application/xhtml+xml\") {\n//             const xhtmlDoc = new xmldom.DOMParser().parseFromString(parsedFile.Value, \"text/html\");\n//             if (xhtmlDoc.getElementById(ID)) {\n//                 return parsedFile.Name;\n//             }\n//         }\n//     }\n//     return;\n//     // publication.ParsedFiles.forEach((parsedFile: ParsedFile, i: number) => {\n//     //     if (parsedFile.Type === \"application/xhtml+xml\") {\n//     //         const xhtmlDoc = new xmldom.DOMParser().parseFromString(parsedFile.Value, \"text/html\");\n//     //         if (xhtmlDoc.getElementById(ID)) {\n//     //             debug(\"xhtmlDoc\" + i, parsedFile.Name);\n//     //         }\n//     //     }\n//     // });\n// };\n\n// const findParInSeqWithID = (seq: Seq, id: string): Par | undefined => {\n//     for (const child of seq.Children) {\n//         // Duck typing ...\n//         if ((child as Seq).Children) {\n//             const found = findParInSeqWithID(child as Seq, id);\n//             if (found) {\n//                 return found;\n//             }\n//             continue;\n//         }\n//         const par = child as Par;\n//         if ((par.Text || par.Audio) &&\n//             par.ID === id) {\n\n//             return par;\n//         }\n//     }\n//     return undefined;\n// };\n// const findParInSmilWithID = (smil: SMIL, id: string): Par | undefined => {\n//     if (smil.Body) {\n//         return findParInSeqWithID(smil.Body, id);\n//     }\n//     return undefined;\n// };\n"]}