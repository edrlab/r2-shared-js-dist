{"version":3,"file":"audiobook.js","sourceRoot":"","sources":["../../../../src/parser/audiobook.ts"],"names":[],"mappings":"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","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as fs from \"fs\";\nimport * as http from \"http\";\nimport * as https from \"https\";\nimport * as path from \"path\";\n\nimport { Publication } from \"@models/publication\";\nimport { LCP } from \"@r2-lcp-js/parser/epub/lcp\";\nimport { TaJsonDeserialize } from \"@r2-lcp-js/serializable\";\nimport { isHTTP } from \"@r2-utils-js/_utils/http/UrlUtils\";\nimport { traverseJsonObjects } from \"@r2-utils-js/_utils/JsonUtils\";\nimport { streamToBufferPromise } from \"@r2-utils-js/_utils/stream/BufferUtils\";\nimport { IStreamAndLength, IZip } from \"@r2-utils-js/_utils/zip/zip\";\nimport { zipLoadPromise } from \"@r2-utils-js/_utils/zip/zipFactory\";\n\nimport { zipHasEntry } from \"../_utils/zipHasEntry\";\n\nconst debug = debug_(\"r2:shared#parser/audiobook\");\n\nfunction absolutizeURLs(rootUrl: string, jsonObj: any) {\n    traverseJsonObjects(jsonObj,\n        (obj) => {\n            if (obj.href && typeof obj.href === \"string\"\n                && !isHTTP(obj.href)) {\n                // obj.href_ = obj.href;\n                obj.href = rootUrl + \"/\" + obj.href;\n            }\n        });\n}\n\nexport async function AudioBookParsePromise(filePath: string, isAudio?: AudioBookis): Promise<Publication> {\n\n    const isAnAudioBook = isAudio || await isAudioBookPublication(filePath);\n\n    // // excludes AudioBookis.RemoteExploded\n    // const canLoad = isAnAudioBook === AudioBookis.LocalExploded ||\n    //     isAnAudioBook === AudioBookis.LocalPacked ||\n    //     isAnAudioBook === AudioBookis.RemotePacked;\n    // if (!canLoad) {\n    //     // TODO? r2-utils-js zip-ext.ts => variant for HTTP without directory listing? (no deterministic zip entries)\n    //     const err = \"Cannot load exploded remote EPUB (needs filesystem access to list directory contents).\";\n    //     debug(err);\n    //     return Promise.reject(err);\n    // }\n\n    let entryName = \"manifest.json\";\n\n    let filePathToLoad = filePath;\n    if (isAnAudioBook === AudioBookis.LocalExploded) { // (must ensure is directory/folder)\n        filePathToLoad = path.dirname(filePathToLoad) + \"/\";\n    } else if (isAnAudioBook === AudioBookis.RemoteExploded) {\n        const url = new URL(filePathToLoad);\n        entryName = path.basename(url.pathname);\n        url.pathname = path.dirname(url.pathname) + \"/\";\n\n        // contains trailing slash\n        filePathToLoad = url.toString();\n    }\n\n    let zip: IZip;\n    try {\n        zip = await zipLoadPromise(filePathToLoad);\n    } catch (err) {\n        return Promise.reject(err);\n    }\n\n    if (!zip.hasEntries()) {\n        return Promise.reject(\"AudioBook zip empty\");\n    }\n    if (isAnAudioBook === AudioBookis.LocalExploded ||\n        isAnAudioBook === AudioBookis.LocalPacked) {\n\n        const has = await zipHasEntry(zip, entryName, undefined);\n        if (!has) {\n            const zipEntries = await zip.getEntries();\n            for (const zipEntry of zipEntries) {\n                debug(zipEntry);\n            }\n            return Promise.reject(\"AudioBook no manifest?!\");\n        }\n    }\n\n    // let entries: string[];\n    // try {\n    //     entries = await zip.getEntries();\n    // } catch (err) {\n    //     console.log(err);\n    //     return Promise.reject(\"Problem getting AudioBook zip entries\");\n    // }\n    // for (const entryName of entries) {\n    //     // debug(\"++ZIP: entry\");\n    //     // debug(entryName);\n\n    //     if (entryName === \"manifest.json\") {\n    //         // import { tryDecodeURI } from \"../_utils/decodeURI\";\n    //         // const entryNameDecoded = tryDecodeURI(entryName);\n    //         // if (!entryNameDecoded) {\n    //         //     return Promise.reject(`Cannot decode URI?! ${entryName}`);\n    //         // }\n    //     }\n    // }\n\n    let manifestZipStream_: IStreamAndLength;\n    try {\n        manifestZipStream_ = await zip.entryStreamPromise(entryName);\n    } catch (err) {\n        debug(err);\n        return Promise.reject(`Problem streaming AudioBook zip entry?! ${entryName}`);\n    }\n    const manifestZipStream = manifestZipStream_.stream;\n    let manifestZipData: Buffer;\n    try {\n        manifestZipData = await streamToBufferPromise(manifestZipStream);\n    } catch (err) {\n        debug(err);\n        return Promise.reject(`Problem buffering AudioBook zip entry?! ${entryName}`);\n    }\n\n    const manifestJsonStr = manifestZipData.toString(\"utf8\");\n    const manifestJson = JSON.parse(manifestJsonStr);\n\n    if (isAnAudioBook === AudioBookis.RemoteExploded) {\n        const url = new URL(filePath);\n        url.pathname = path.dirname(url.pathname);\n        absolutizeURLs(url.toString(), manifestJson);\n    }\n\n    const publication = TaJsonDeserialize<Publication>(manifestJson, Publication);\n\n    publication.AddToInternal(\"type\", \"audiobook\");\n    publication.AddToInternal(\"zip\", zip);\n\n    const lcpEntryName = \"license.lcpl\";\n    let checkLCP = true; // allows isAnAudioBook === AudioBookis.RemoteExploded\n    let hasLCP = false; // only if zipHasEntry() verifies presence of lcpEntryName (AudioBookis.LocalExploded|Packed)\n    if (isAnAudioBook === AudioBookis.LocalExploded ||\n        isAnAudioBook === AudioBookis.LocalPacked) {\n        const has = await zipHasEntry(zip, lcpEntryName, undefined);\n        if (!has) {\n            checkLCP = false;\n        } else {\n            hasLCP = true;\n        }\n    }\n    if (checkLCP) {\n        let lcpZipStream_: IStreamAndLength | undefined;\n        try {\n            lcpZipStream_ = await zip.entryStreamPromise(lcpEntryName);\n        } catch (err) {\n            if (hasLCP) {\n                debug(err);\n                return Promise.reject(`Problem streaming AudioBook LCP zip entry?! ${entryName}`);\n            } else {\n                debug(\"Audiobook no LCP.\");\n            }\n            checkLCP = false;\n        }\n        if (checkLCP && lcpZipStream_) {\n            const lcpZipStream = lcpZipStream_.stream;\n            let lcpZipData: Buffer;\n            try {\n                lcpZipData = await streamToBufferPromise(lcpZipStream);\n            } catch (err) {\n                debug(err);\n                return Promise.reject(`Problem buffering AudioBook LCP zip entry?! ${entryName}`);\n            }\n\n            const lcpJsonStr = lcpZipData.toString(\"utf8\");\n            const lcpJson = JSON.parse(lcpJsonStr);\n\n            const lcpl = TaJsonDeserialize<LCP>(lcpJson, LCP);\n            lcpl.ZipPath = lcpEntryName;\n            lcpl.JsonSource = lcpJsonStr;\n            lcpl.init();\n\n            publication.LCP = lcpl;\n        }\n    }\n\n    return Promise.resolve(publication);\n}\n\n// https://api.archivelab.org/books/armand_durand/opds_audio_manifest\n// https://api.archivelab.org/books/art_letters_1809_librivox/opds_audio_manifest\n// curl -s -L -I -X GET xxx\n// Content-Type: application/audiobook+json; charset=utf-8\nexport enum AudioBookis {\n    LocalExploded = \"LocalExploded\",\n    LocalPacked = \"LocalPacked\",\n    RemoteExploded = \"RemoteExploded\",\n    // RemotePacked = \"RemotePacked\",\n}\n\nasync function doRequest(u: string): Promise<AudioBookis> {\n    return new Promise((resolve, reject) => {\n        const url = new URL(u);\n        const secure = url.protocol === \"https:\";\n        const options = {\n            headers: {\n                \"Accept\": \"*/*,application/audiobook+json\",\n                \"Accept-Language\": \"en-UK,en-US;q=0.7,en;q=0.5\",\n                \"Host\": url.host,\n                \"User-Agent\": \"Readium2-AudioBooks\",\n            },\n            host: url.host,\n            method: \"GET\",\n            path: url.pathname + url.search,\n            port: secure ? 443 : 80,\n            protocol: url.protocol,\n        };\n        debug(JSON.stringify(options));\n        (secure ? https : http).request(options, (res) => {\n            if (!res) {\n                reject(`HTTP no response ${u}`);\n                return;\n            }\n\n            debug(res.statusCode);\n            debug(JSON.stringify(res.headers));\n\n            if (res.statusCode && (res.statusCode >= 300 && res.statusCode < 400)) {\n                const loc = res.headers.Location || res.headers.location;\n                if (loc && loc.length) {\n                    const l = Array.isArray(loc) ? loc[0] : loc;\n                    process.nextTick(async () => {\n                        try {\n                            const redirectRes = await doRequest(l);\n                            resolve(redirectRes);\n                        } catch (err) {\n                            reject(`HTTP audiobook redirect, then fail ${u} ${err}`);\n                        }\n                    });\n                } else {\n                    reject(`HTTP audiobook redirect without location?! ${u}`);\n                }\n                return;\n            }\n            const type = res.headers[\"Content-Type\"] || res.headers[\"content-type\"];\n            if (type) {\n                if (type.includes(\"application/audiobook+json\")) {\n                    resolve(AudioBookis.RemoteExploded);\n                    return;\n                }\n                if (type.includes(\"application/json\")) {\n                    res.setEncoding(\"utf8\");\n\n                    let responseBody = \"\";\n                    res.on(\"data\", (chunk) => {\n                        responseBody += chunk;\n                    });\n                    res.on(\"end\", () => {\n                        try {\n                            const manJson = JSON.parse(responseBody);\n                            if (manJson.metadata && manJson.metadata[\"@type\"] &&\n                                /http[s]?:\\/\\/schema\\.org\\/Audiobook$/.test(manJson.metadata[\"@type\"])\n                                ) {\n                                resolve(AudioBookis.RemoteExploded);\n                                return;\n                            } else {\n                                reject(`HTTP JSON not audiobook ${u}`);\n                            }\n                        } catch (ex) {\n                            debug(ex);\n                            reject(`HTTP audiobook invalid JSON?! ${u} ${ex}`);\n                        }\n                    });\n\n                    return;\n                }\n            }\n            reject(`Not HTTP audiobook type ${u}`);\n        }).on(\"error\", (err) => {\n            debug(err);\n            reject(`HTTP error ${u} ${err}`);\n        }).end();\n    });\n}\n\nexport async function isAudioBookPublication(urlOrPath: string): Promise<AudioBookis> {\n    let p = urlOrPath;\n    const isHttp = isHTTP(urlOrPath);\n    if (isHttp) {\n        const url = new URL(urlOrPath);\n        p = url.pathname;\n    }\n\n    const fileName = path.basename(p);\n    const ext = path.extname(fileName).toLowerCase();\n\n    const audio = /\\.audiobook$/.test(ext);\n    const audioLcp = /\\.lcpa$/.test(ext);\n    const audioLcpAlt = /\\.lcpaudiobook$/.test(ext);\n    if (audio || audioLcp || audioLcpAlt) {\n        // return isHttp ? AudioBookis.RemotePacked : AudioBookis.LocalPacked;\n        if (!isHttp) {\n            return AudioBookis.LocalPacked;\n        }\n    }\n\n    if (!isHttp && fileName === \"manifest.json\") {\n        // const manPath = fileName === \"manifest.json\" ? p : path.join(p, \"manifest.json\");\n        if (fs.existsSync(p)) {\n            const manStr = fs.readFileSync(p, { encoding: \"utf8\" });\n            const manJson = JSON.parse(manStr);\n            if (manJson.metadata && manJson.metadata[\"@type\"] &&\n                /http[s]?:\\/\\/schema\\.org\\/Audiobook$/.test(manJson.metadata[\"@type\"])\n            ) {\n                return AudioBookis.LocalExploded;\n            }\n        }\n    }\n\n    // // filePath.replace(/\\//, \"/\").endsWith(\"audiobook/manifest.json\")\n    // if (/audiobook[\\/|\\\\]manifest.json$/.test(p)) {\n    //     return isHttp ? AudioBookis.RemoteExploded : AudioBookis.LocalExploded;\n    // }\n\n    if (isHttp) {\n        return doRequest(urlOrPath);\n    }\n\n    return Promise.reject(\"Cannot determine audiobook type\");\n}\n"]}