{"version":3,"file":"daisy-convert-to-epub.js","sourceRoot":"","sources":["../../../../src/parser/daisy-convert-to-epub.ts"],"names":[],"mappings":";;;;AAOA,8BAAgC;AAChC,uBAAyB;AACzB,2BAA6B;AAC7B,+BAAiC;AACjC,6BAA+B;AAC/B,6BAA+B;AAE/B,uDAAyD;AACzD,6CAA4C;AAC5C,mEAAyD;AAEzD,6DAAgD;AAChD,wDAA6E;AAG7E,yDAE6B;AAE7B,IAAM,KAAK,GAAG,MAAM,CAAC,wCAAwC,CAAC,CAAC;AAE/D,SAAS,UAAU,CAAC,MAAc;IAC9B,IAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAErC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;QACzB,UAAU,CAAC,OAAO,CAAC,CAAC;QACpB,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;KACzB;AACL,CAAC;AAGM,IAAM,2BAA2B,GAAG,UACvC,aAAqB,EAAE,WAAwB;;QAE/C,WAAO,IAAI,OAAO,CAAC,UAAO,OAAO,EAAE,MAAM;;;;;;4BAG/B,eAAe,GAAG,CAAA,MAAA,WAAW,CAAC,QAAQ,0CAAE,cAAc;gCACxD,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,eAAe,CAAC;4BAG5E,WAAW,GAAG,CAAA,MAAA,WAAW,CAAC,QAAQ,0CAAE,cAAc;gCACpD,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,UAAU,CAAC;4BAGvE,UAAU,GAAG,CAAA,MAAA,WAAW,CAAC,QAAQ,0CAAE,cAAc;gCACnD,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,oBAAoB,CAAC,KAAK,SAAS,CAAC;4BAEtE,WAAW,GAAG,WAAW,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;4BACxD,IAAI,CAAC,WAAW,EAAE;gCACd,KAAK,CAAC,sBAAsB,CAAC,CAAC;gCAC9B,WAAO,MAAM,CAAC,sBAAsB,CAAC,EAAC;6BACzC;4BACK,GAAG,GAAG,WAAW,CAAC,KAAa,CAAC;4BAEhC,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAG,WAAW,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,qBAAqB,CAAC,qBAAiB,CAAC,CAAC;4BAC5J,UAAU,CAAC,aAAa,CAAC,CAAC;4BAGpB,OAAO,GAAG,IAAI,cAAO,EAAE,CAAC;;;;4BAEpB,WAAW,GAAG,EAAE,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC;4BACxD,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC;iCACjC,EAAE,CAAC,OAAO,EAAE;gCACT,KAAK,CAAC,WAAW,CAAC,CAAC;gCACnB,IAAI,SAAS,EAAE;oCACX,YAAY,CAAC,SAAS,CAAC,CAAC;oCACxB,SAAS,GAAG,SAAS,CAAC;oCACtB,OAAO,CAAC,aAAa,CAAC,CAAC;iCAC1B;4BACL,CAAC,CAAC;iCACD,EAAE,CAAC,OAAO,EAAE,UAAC,CAAM;gCAChB,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;gCACtB,MAAM,CAAC,CAAC,CAAC,CAAC;4BACd,CAAC,CAAC,CAAC;4BAGD,MAAM,GAAG,KAAK,CAAC,aAAa,CAAC;gCAC/B,MAAM,EAAE,yCAAyC;6BAGpD,CAAC,CAAC;4BAsFG,YAAY,GAAG;gCACjB,SAAS;gCACT,SAAS;gCACT,YAAY;gCACZ,QAAQ;gCACR,KAAK;gCACL,YAAY;gCACZ,MAAM;gCACN,YAAY;gCACZ,QAAQ;gCACR,SAAS;gCACT,MAAM;gCACN,KAAK;gCACL,UAAU;gCACV,YAAY;gCACZ,UAAU;gCACV,KAAK;gCACL,WAAW;gCACX,UAAU;gCACV,QAAQ;gCACR,UAAU;gCACV,aAAa;gCACb,IAAI;gCACJ,UAAU;gCACV,KAAK;gCACL,OAAO;gCACP,SAAS;gCACT,QAAQ;gCACR,QAAQ;gCACR,QAAQ;gCACR,QAAQ;gCACR,QAAQ;gCACR,QAAQ;gCACR,KAAK;gCACL,MAAM;gCACN,WAAW;gCACX,SAAS;gCACT,MAAM;gCACN,MAAM;gCACN,MAAM;gCACN,SAAS;gCACT,SAAS;gCACT,MAAM;gCACN,UAAU;gCACV,YAAY;gCACZ,MAAM;gCACN,MAAM;gCACN,KAAK;gCACL,KAAK;gCACL,GAAG;gCACH,GAAG;gCACH,QAAQ;gCACR,SAAS;gCACT,YAAY;gCACZ,MAAM;gCACN,SAAS;gCACT,OAAO;6BACV,CAAC;4BAUI,6BAA2B,UAAC,EAAoB;gCAClD,IAAI,QAAQ,GAAW,CAAC,CAAC;gCAEzB,IAAI,OAAO,EAAE,CAAC,cAAc,KAAK,WAAW;oCACxC,OAAO,EAAE,CAAC,YAAY,KAAK,WAAW,EAAE;oCAExC,QAAQ,GAAG,EAAE,CAAC,YAAY,GAAG,EAAE,CAAC,cAAc,CAAC;iCAElD;qCAAM,IAAI,EAAE,CAAC,QAAQ,EAAE;oCACpB,KAAoB,UAAW,EAAX,KAAA,EAAE,CAAC,QAAQ,EAAX,cAAW,EAAX,IAAW,EAAE;wCAA5B,IAAM,KAAK,SAAA;wCACZ,QAAQ,IAAI,0BAAwB,CAAC,KAAK,CAAC,CAAC;qCAC/C;iCACJ;gCAED,OAAO,QAAQ,CAAC;4BACpB,CAAC,CAAC;4BAEI,+BAA6B,UAC/B,EAAoB,EACpB,qBAAyC;gCAEzC,IAAI,WAA+B,CAAC;gCAEpC,IAAI,qBAAqB,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,KAAK,EAAE;oCAC/C,WAAW,GAAG,qBAAqB,CAAC;oCACpC,EAAE,CAAC,IAAI,GAAM,WAAW,UAAI,EAAE,CAAC,KAAK,IAAI,OAAO,CAAE,CAAC;iCACrD;qCAAM,IAAI,EAAE,CAAC,IAAI,EAAE;oCAGhB,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;oCAC7C,WAAW,GAAG,EAAE,CAAC,IAAI,CAAC;oCACtB,IAAM,CAAC,GAAG,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;oCACnC,IAAI,CAAC,GAAG,CAAC,EAAE;wCACP,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;qCAC1C;iCACJ;gCACD,IAAI,EAAE,CAAC,QAAQ,EAAE;oCACb,KAAoB,UAAW,EAAX,KAAA,EAAE,CAAC,QAAQ,EAAX,cAAW,EAAX,IAAW,EAAE;wCAA5B,IAAM,KAAK,SAAA;wCACZ,IAAM,YAAY,GAAG,4BAA0B,CAAC,KAAK,EAAE,qBAAqB,CAAC,CAAC;wCAC9E,IAAI,CAAC,YAAY,EAAE;4CACf,KAAK,CAAC,wCAAwC,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;yCACxE;6CAAM,IAAI,WAAW,IAAI,WAAW,KAAK,YAAY,EAAE;4CACpD,KAAK,CAAC,wDAAwD,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;yCAC9F;wCACD,IAAI,CAAC,WAAW,EAAE;4CACd,WAAW,GAAG,YAAY,CAAC;yCAC9B;qCACJ;iCACJ;gCAED,OAAO,WAAW,CAAC;4BACvB,CAAC,CAAC;4BAGI,aAAqC,EAAE,CAAC;4BAExC,kBAAgB,UAAC,KAAa,EAAE,WAAmB;gCACrD,KAAmB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;oCAArB,IAAM,IAAI,cAAA;oCACX,IAAI,IAAI,CAAC,WAAW,KAAK,WAAW,EAAE;wCAClC,OAAO,IAAI,CAAC;qCACf;yCAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;wCACtB,IAAM,SAAS,GAAG,eAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;wCAC5D,IAAI,SAAS,EAAE;4CACX,OAAO,SAAS,CAAC;yCACpB;qCACJ;iCACJ;gCACD,OAAO,SAAS,CAAC;4BACrB,CAAC,CAAC;4BAEI,sBAAsB,GAAG,UAAO,aAAqB;;;;;4CAEnD,OAAO,GAAG,UAAQ,CAAC,aAAa,CAAC,CAAC;iDAClC,CAAC,OAAO,EAAR,cAAQ;4CACQ,WAAM,0CAAsB,CAAC,aAAa,EAAE,aAAa,EAAE,GAAG,CAAC,EAAA;;4CAAzE,OAAO,GAAG,SAA+D;4CAC/E,IAAI,CAAC,OAAO,EAAE;gDACV,KAAK,CAAC,yBAAyB,EAAE,OAAO,CAAC,CAAC;gDAC1C,WAAO,SAAS,EAAC;6CACpB;4CACD,OAAO,GAAG,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC,eAAe,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;4CAC7E,UAAQ,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC;;;4CAMhC,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;4CAC/D,WAA0B,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM,EAAE;gDAAjB,KAAK;gDAKN,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,EAAE,IAAK,OAAA,EAAE,EAAF,CAAE,CAAC,CAAC;gDACzF,WAAwC,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;oDAA/B,YAAY;oDACnB,IAAI,YAAY,CAAC,UAAU,EAAE;wDACzB,YAAY,CAAC,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;qDACrD;iDACJ;gDAEK,KAAK,GAAG,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;gDACjC,WAAW,GAAM,aAAa,SAAI,KAAO,CAAC;gDAC1C,WAAW,GAAG,eAAa,CAAC,WAAW,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;gDAC1D,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;gDAEnD,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;gDAC3D,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;6CAC/B;4CAEK,WAAW,GAAG,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;4CACtD,cAAc,GAAG,IAAI,MAAM,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;4CAC3E,UAAU,GAAG,cAAc;iDAC5B,OAAO,CAAC,0CAAwC,EAAE,EAAE,CAAC;iDACrD,OAAO,CAAC,OAAO,EAAE,WAAW,CAAC;iDAC7B,OAAO,CAAC,QAAQ,EAAE,YAAY,CAAC;iDAC/B,OAAO,CAAC,cAAc,EAAE,kBAAkB,CAAC;iDAC3C,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC;iDACjC,OAAO,CAAC,OAAO,EAAE,uBAAuB,CAAC;iDACzC,OAAO,CAAC,OAAO,EAAE,qBAAqB,CAAC;iDACvC,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC;iDAC7B,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,CAC3B;4CAEC,OAAO,GAAG,oNAIf,aAAa,mCAExB,UAAU,gBAEf,CAAC;4CACoB,YAAY,GAAG,aAAa,CAAC,OAAO,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;4CAEhE,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,YAAY,CAAC,CAAC;4CACtD,WAAO,YAAY,EAAC;;;iCACvB,CAAC;4BAEI,kBAAkB,GAAW,EAAE,CAAC;iCAClC,WAAW,CAAC,KAAK,EAAjB,cAAiB;4BAEjB,kBAAgB,GAAG,EAAE,CAAC;4BAElB,gBAAgB,SAAkB,CAAC;4BACnC,UAAU,GAAG,CAAC,CAAC,CAAC;kCACoB,EAAjB,KAAA,WAAW,CAAC,KAAK;;;iCAAjB,CAAA,cAAiB,CAAA;4BAA7B,QAAQ;4BACf,UAAU,EAAE,CAAC;4BACb,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE;gCACzB,cAAS;6BACZ;iCAEG,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,EAAnC,cAAmC;4BAEnC,WAAM,yCAAqB,CAAC,WAAW,EAAE,QAAQ,CAAC,aAAa,CAAC,EAAA;;4BAAhE,SAAgE,CAAC;4BAEjE,IAAI,eAAe,IAAI,WAAW,EAAE;gCAChC,mCAAe,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;6BAC9D;;;4BAGL,IAAI,eAAe,IAAI,WAAW,EAAE;gCAC1B,WAAW,GAAG,0BAAwB,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;gCACrE,IAAI,WAAW,EAAE;oCACb,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,EAAE;wCAClC,QAAQ,CAAC,aAAa,CAAC,QAAQ,GAAG,WAAW,CAAC;wCAE9C,mCAAe,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;qCAC1C;yCAAM;wCACH,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;4CACzE,KAAK,CAAC,iDAAiD,EACnD,QAAQ,CAAC,aAAa,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;yCACrD;qCACJ;iCACJ;gCAED,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,aAAa;oCAElD,OAAO,gBAAgB,CAAC,aAAa,CAAC,gBAAgB,KAAK,WAAW;oCACtE,OAAO,QAAQ,CAAC,aAAa,CAAC,gBAAgB,KAAK,WAAW,EAAE;oCAE1D,GAAG,GAAG,QAAQ,CAAC,aAAa,CAAC,gBAAgB;wCAC/C,gBAAgB,CAAC,aAAa,CAAC,gBAAgB,CAAC;oCACpD,IAAI,GAAG,GAAG,CAAC,EAAE;wCACT,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,QAAQ,EAAE;4CAC1C,gBAAgB,CAAC,aAAa,CAAC,QAAQ,GAAG,GAAG,CAAC;4CAE9C,mCAAe,CAAC,GAAG,EAAE,gBAAgB,CAAC,CAAC;yCAC1C;6CAAM;4CACH,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;gDACzE,KAAK,CAAC,iDAAiD,EACnD,gBAAgB,CAAC,aAAa,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;6CACrD;yCACJ;qCACJ;iCACJ;gCACD,gBAAgB,GAAG,QAAQ,CAAC;6BAC/B;4BAEG,WAAW,SAAoB,CAAC;4BAEpC,IAAI,WAAW,EAAE;gCACP,qBAAqB,GACvB,MAAA,QAAQ,CAAC,aAAa,CAAC,aAAa,0CAAE,OAAO,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;gCACvE,IAAI,qBAAqB,EAAE;oCACvB,WAAW,GAAG,4BAA0B,CAAC,QAAQ,CAAC,aAAa,EAAE,qBAAqB,CAAC,CAAC;iCAC3F;6BACJ;iCAAM;gCACH,WAAW,GAAG,4BAA0B,CAAC,QAAQ,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;6BAC/E;iCAEG,WAAW,EAAX,cAAW;iCACP,CAAA,WAAW,IAAI,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAA,EAAnD,cAAmD;4BACnD,WAAM,sBAAsB,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,EAAA;;4BAAlE,SAAkE,CAAC;4BAE7D,QAAQ,GAAG,IAAI,uBAAI,EAAE,CAAC;4BAC5B,QAAQ,CAAC,IAAI,GAAG,WAAW,CAAC;4BAC5B,QAAQ,CAAC,QAAQ,GAAG,uBAAuB,CAAC;4BAC5C,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;;;4BAItC,IAAI,CAAC,kBAAgB,CAAC,WAAW,CAAC,EAAE;gCAChC,kBAAgB,CAAC,WAAW,CAAC,GAAG;oCAC5B,KAAK,EAAE,UAAU;oCACjB,GAAG,EAAE,EAAE;iCACV,CAAC;6BACL;4BAED,kBAAgB,CAAC,WAAW,CAAC,CAAC,KAAK,GAAG,UAAU,CAAC;4BACjD,kBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;;;4BApFhD,IAAiB,CAAA;;;4BAwF5C,WAAW,CAAC,KAAK,GAAG,EAAE,CAAC;4BAEjB,eAAe,GAAW,EAAE,CAAC;4BAE7B,OAAO,6BAAe,kBAAkB,CAAC,CAAC;kCAIL,EAArB,KAAA,WAAW,CAAC,SAAS;;;iCAArB,CAAA,cAAqB,CAAA;4BAAhC,OAAO;4BAEd,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;gCACtB,eAAS;6BACZ;iCACG,CAAA,OAAO,CAAC,QAAQ,KAAK,UAAU,IAAI,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA,EAAvE,eAAuE;4BAEzD,WAAM,0CAAsB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,EAAA;;4BAA9E,OAAO,GAAG,SAAoE;4BAClF,IAAI,CAAC,OAAO,EAAE;gCACV,KAAK,CAAC,yBAAyB,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;gCACtD,eAAS;6BACZ;4BAGD,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,sBAAsB,EAAE,UAAC,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO;gCAC3E,IAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;gCAClD,OAAO,SAAO,MAAM,SAAM,CAAC;4BAC/B,CAAC,CAAC,CAAC;4BAGH,WAAsC,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAY,EAAE;gCAA7B,WAAW;gCAEZ,KAAK,GAAG,IAAI,MAAM,CACpB,wBAAwB,WAAW,uBAAqB,EAAE,GAAG,CAAC,CAAC;gCAWnE,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;gCAG/C,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;6BAClD;4BAGD,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,EAAE,UAAC,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO;gCAC9E,IAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;gCAC3D,OAAO,OAAK,OAAO,OAAI,CAAC;4BAC5B,CAAC,CAAC,CAAC;4BAMH,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;4BAO7D,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;;iCAEvB,CAAA,OAAO,CAAC,QAAQ,KAAK,0BAA0B,IAAI,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA,EAAvF,eAAuF;4BAsqB9E,WAAM,0CAAsB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,EAAA;;4BAAhF,SAAS,GAAG,SAAoE;4BACpF,IAAI,CAAC,SAAS,EAAE;gCACZ,KAAK,CAAC,yBAAyB,EAAE,SAAS,CAAC,CAAC;gCAC5C,eAAS;6BACZ;4BACD,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;4BAC/C,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,SAAS,EAAE,sDAAsD,CAAC,CAAC;4BAC3F,SAAS,GAAG,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC,eAAe,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;4BAEnF,KAAK,GAAG,MAAA,SAAS,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,0CAAE,WAAW,CAAC;4BACvE,IAAI,KAAK,EAAE;gCACP,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;gCACrB,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;oCACf,KAAK,GAAG,IAAI,CAAC;iCAChB;6BACJ;4BAEK,YAAY,GAAG,SAAS,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;4BAC5D,KAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gCACpC,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gCACzC,IAAI,CAAC,WAAW,EAAE;oCACd,SAAS;iCACZ;gCACK,IAAI,GAAG,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;gCAC9C,IAAI,IAAI,EAAE;oCAEL,WAAmB,CAAC,OAAO,GAAG,IAAI,CAAC;iCAEvC;6BACJ;4BAMD,WAAsC,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAY,EAAE;gCAA7B,WAAW;gCAKZ,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,EAAE,IAAK,OAAA,EAAE,EAAF,CAAE,CAAC,CAAC;gCACvF,WAAoB,EAAH,WAAG,EAAH,iBAAG,EAAH,IAAG,EAAE;oCAAX,EAAE;oCACT,EAAE,CAAC,YAAY,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;oCACtC,GAAG,GAAG,EAAE,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;oCACrC,EAAE,CAAC,YAAY,CAAC,OAAO,EAAE,MAAG,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,IAAG,WAAW,QAAK,CAAC,CAAC;oCAEtE,EAAU,CAAC,OAAO;wCACf,CAAC,CAAC,WAAW,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;4CAClC,CAAC,CAAC,WAAW,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;gDAChC,CAAC,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;oDACnC,CAAC,CAAC,WAAW,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;wDAChC,CAAC,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC;4DACzC,CAAC,CAAC,WAAW,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;gEACtC,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;oEACnC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oCAC5C,IAAI,WAAW,KAAK,SAAS,EAAE;wCAE3B,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;qCAC7C;yCAAM,IAAI,WAAW,KAAK,YAAY,EAAE;wCAErC,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;qCAC9C;yCAAM,IAAI,WAAW,KAAK,MAAM,EAAE;wCAE/B,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;qCACxC;yCAAM,IAAI,WAAW,KAAK,UAAU,EAAE;wCAEnC,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;qCACxC;yCAAM,IAAI,WAAW,KAAK,SAAS,EAAE;wCAElC,EAAE,CAAC,YAAY,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;qCAC3C;iCACJ;6BACJ;4BAGK,WAAW,GACb,MAAM,CAAC,2CAA2C,EAAE,SAAS,CAA4B,CAAC;4BACxF,QAAQ,GAAa,EAAE,CAAC;4BAC9B,WAAoC,EAAX,2BAAW,EAAX,yBAAW,EAAX,IAAW,EAAE;gCAA3B,UAAU;gCACjB,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;oCACvB,SAAS;iCACZ;gCACD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;oCAC5C,SAAS;iCACZ;gCACK,KAAK,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC;gCACjE,IAAI,CAAC,KAAK,EAAE;oCACR,SAAS;iCACZ;gCACK,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;gCAC7B,IAAI,IAAI,EAAE;oCACN,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iCACvB;6BACJ;4BAEK,QAAQ,GAAG,MAAM,CAAC,eAAe,EAAE,SAAS,CAAc,CAAC;4BACjE,WAA8B,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;gCAArB,OAAO;gCACR,GAAG,GAAG,OAAO,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;gCAC5C,IAAI,GAAG,EAAE;oCACL,OAAO,CAAC,YAAY,CAAC,cAAc,EAAE,GAAG,CAAC,CAAC;iCAC7C;gCACD,OAAO,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;6BACtC;4BAUK,cAAc,GAAG,IAAI,MAAM,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC,SAAS,CAAC;iCACzE,OAAO,CAAC,yDAAyD,EAAE,wCAAwC,CAAC;iCAC5G,OAAO,CAAC,0DAA0D,EAAE,GAAG,CAAC;iCACxE,OAAO,CAAC,mBAAmB,EACxB,qEAErB,CAAC;iCACiB,OAAO,CAAC,oBAAoB,EACzB,8CAG1B,KAAK,CAAC,CAAC,CAAC,YAAU,KAAK,aAAU,CAAC,CAAC,CAAC,EAAE,QACvC,CAAC;iCACuB,OAAO,CAAC,oBAAoB,EACzB,OAC1B,QAAQ,CAAC,MAAM,CAAC,UAAC,EAAE,EAAE,EAAE;gCACO,OAAO,EAAE,GAAG,IAAI,IAAG,uDAAgD,EAAE,UAAM,CAAA,CAAC;4BAChF,CAAC,EAAE,EAAE,CAAC,gBAEjC,CAAC,CAAC;4BACuB,aAAa,GAAG,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;4BAMvE,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,aAAa,CAAC,CAAC;4BAExD,WAAW,GAAG,8BAAe,CAAC,OAAO,CAAC,CAAC;4BAEvC,YAAY,GAAG,gCAAiB,CAAO,WAAW,EAAE,uBAAI,CAAC,CAAC;4BAChE,YAAY,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC;4BAC3C,YAAY,CAAC,QAAQ,GAAG,uBAAuB,CAAC;4BAEhD,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;;;iCAEpB,CAAA,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC;gCAC5C,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC;gCACrC,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA,EAF9B,eAE8B;4BAExB,WAAM,6CAAyB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,EAAA;;4BAA9E,IAAI,GAAG,SAAuE;4BACpF,IAAI,IAAI,EAAE;gCACN,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;6BAChD;4BAED,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;;;4BA93BhB,IAAqB,CAAA;;;4BAk4B3C,IAAI,kBAAgB,EAAE;gCAClB,MAAM,CAAC,IAAI,CAAC,kBAAgB,CAAC,CAAC,OAAO,CAAC,UAAC,WAAW;oCAC9C,IAAI,CAAC,kBAAgB,EAAE;wCACnB,OAAO;qCACV;oCACD,KAAK,CAAC,eAAe,GAAG,WAAW,CAAC,CAAC;oCACrC,IAAM,GAAG,GAAG,kBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC;oCAC9C,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;wCAClB,KAAK,CAAC,mBAAmB,GAAG,WAAW,CAAC,CAAC;wCACzC,OAAO;qCACV;oCAED,IAAM,mBAAmB,GAAG,IAAI,gCAAgB,EAAE,CAAC;oCACnD,mBAAmB,CAAC,aAAa,GAAG,SAAS,CAAC;oCAC9C,mBAAmB,CAAC,WAAW,GAAG,IAAI,CAAC;oCACvC,mBAAmB,CAAC,IAAI,GAAG,EAAE,CAAC;oCAC9B,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oCACzC,mBAAmB,CAAC,QAAQ,GAAG,CAAC,CAAC;oCAEjC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;oCACX,KAAiB,UAAG,EAAH,WAAG,EAAH,iBAAG,EAAH,IAAG,EAAE;wCAAjB,IAAM,EAAE,YAAA;wCACT,CAAC,EAAE,CAAC;wCACJ,IAAI,EAAE,CAAC,QAAQ,EAAE;4CACb,KAAK,CAAC,kBAAgB,CAAC,QAAK,GAAG,WAAW,CAAC,CAAC;4CAE5C,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE;gDAC/B,mBAAmB,CAAC,QAAQ,GAAG,EAAE,CAAC;6CACrC;4CACD,mBAAmB,CAAC,QAAQ,GAAG,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;4CAEhF,IAAI,EAAE,CAAC,QAAQ,EAAE;gDACb,mBAAmB,CAAC,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC;6CAC/C;yCACJ;qCACJ;oCACD,kBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,GAAG,CAAC,mBAAmB,CAAC,CAAC;gCAC9D,CAAC,CAAC,CAAC;gCAEG,qBAAqB,GAAG,MAAM,CAAC,IAAI,CAAC,kBAAgB,CAAC,CAAC,GAAG,CAAC,UAAC,WAAW;oCACxE,IAAI,CAAC,kBAAgB,EAAE;wCACnB,OAAO,SAAS,CAAC;qCACpB;oCACD,OAAO;wCACH,KAAK,EAAE,kBAAgB,CAAC,WAAW,CAAC,CAAC,KAAK;wCAC1C,EAAE,EAAE,kBAAgB,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wCACxC,WAAW,aAAA;qCACd,CAAC;gCACN,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,EAAD,CAAC,CAAC,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;oCAE1B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,EAAE;wCAC7B,OAAO,CAAC,CAAC,CAAC;qCACb;oCAED,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,EAAE;wCAC7B,OAAO,CAAC,CAAC;qCACZ;oCAED,OAAO,CAAC,CAAC;gCACb,CAAC,CAAC,CAAC;oDAEQ,YAAY;oCACnB,IAAI,CAAC,YAAY,EAAE;;qCAElB;oCACD,KAAK,CAAC,eAAe,EAAE,YAAY,CAAC,KAAK,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;oCAErE,IAAM,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC,UAAC,CAAC;wCAC9B,OAAO,CAAC,CAAC,WAAW,KAAK,YAAY,CAAC,WAAW,CAAC;oCACtD,CAAC,CAAC,CAAC;oCAEH,IAAI,CAAC,UAAU,EAAE;wCACb,KAAK,CAAC,cAAc,CAAC,CAAC;qCACzB;yCAAM,IAAI,UAAU,CAAC,WAAW,KAAK,YAAY,CAAC,WAAW,EAAE;wCAC5D,KAAK,CAAC,iDAAiD,EACnD,UAAU,CAAC,WAAW,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;qCACzD;yCAAM;wCACH,IAAI,eAAe,IAAI,WAAW,EAAE;4CAChC,UAAU,CAAC,aAAa,GAAG,YAAY,CAAC,EAAE,CAAC;4CAE3C,IAAI,YAAY,CAAC,EAAE,CAAC,QAAQ,EAAE;gDAC1B,UAAU,CAAC,QAAQ,GAAG,YAAY,CAAC,EAAE,CAAC,QAAQ,CAAC;6CAClD;4CAED,IAAM,KAAK,GAAG,yBAAuB,YAAY,CAAC,KAAK,UAAO,CAAC;4CAO/D,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;gDACxB,UAAU,CAAC,UAAU,GAAG,IAAI,gCAAU,EAAE,CAAC;6CAC5C;4CACD,UAAU,CAAC,UAAU,CAAC,YAAY,GAAG,KAAK,CAAC;4CAK3C,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;gDACvB,UAAU,CAAC,SAAS,GAAG,EAAE,CAAC;6CAC7B;4CACD,IAAM,MAAM,GAAG,IAAI,uBAAI,EAAE,CAAC;4CAC1B,MAAM,CAAC,IAAI,GAAG,KAAK,CAAC;4CACpB,MAAM,CAAC,QAAQ,GAAG,+BAA+B,CAAC;4CAClD,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC,QAAQ,CAAC;4CACtC,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;4CAElC,IAAM,SAAS,GAAG,8BAAe,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;4CACnD,IAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;4CAC/D,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC,CAAC;4CAEjD,KAAK,CAAC,sBAAsB,EACxB,YAAY,CAAC,KAAK,EAAE,UAAU,CAAC,WAAW,EAAE,UAAU,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;yCAC/E;6CAAM;4CACH,KAAK,CAAC,iCAAiC,EAAE,YAAY,CAAC,KAAK,EAAE,UAAU,CAAC,WAAW,CAAC,CAAC;yCACxF;wCACD,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qCACtC;;gCAzDL,WAAgD,EAArB,+CAAqB,EAArB,mCAAqB,EAArB,IAAqB;oCAArC,YAAY;4CAAZ,YAAY;iCA0DtB;6BACJ;4BAED,WAAW,CAAC,SAAS,GAAG,eAAe,CAAC;4BAExC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE;gCACvB,WAAW,CAAC,QAAQ,GAAG,IAAI,mBAAQ,EAAE,CAAC;6BACzC;4BAED,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,EAAE;gCACtC,WAAW,CAAC,QAAQ,CAAC,cAAc,GAAG,EAAE,CAAC;6BAC5C;4BACD,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,kCAAkC;gCAClE,WAAW,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC;4BAEtF,4BAA0B,UAAC,MAAe;gCAC5C,IAAI,MAAM,CAAC,UAAU,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE;oCAE/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wCAC/C,IAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;wCACnC,IAAI,KAAK,CAAC,QAAQ,KAAK,CAAC,EAAE;4CACtB,IAAM,OAAO,GAAG,KAAgB,CAAC;4CACjC,IAAI,OAAO,CAAC,SAAS,IAAI,OAAO,CAAC,SAAS,CAAC,WAAW,EAAE,KAAK,MAAM,EAAE;gDACjE,OAAO,OAAO,CAAC;6CAClB;yCACJ;qCACJ;oCAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wCAC/C,IAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;wCACnC,IAAI,KAAK,CAAC,QAAQ,KAAK,CAAC,EAAE;4CACtB,IAAM,OAAO,GAAG,KAAgB,CAAC;4CACjC,IAAM,KAAK,GAAG,yBAAuB,CAAC,OAAO,CAAC,CAAC;4CAC/C,IAAI,KAAK,EAAE;gDACP,OAAO,KAAK,CAAC;6CAChB;yCACJ;qCACJ;iCACJ;gCACD,OAAO,SAAS,CAAC;4BACrB,CAAC,CAAC;4BAEI,gBAAc,UAAO,IAAU;;;;;4CAE7B,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC;4CAC5B,IAAI,CAAC,IAAI,EAAE;gDACP,WAAO;6CACV;4CACD,IAAI,WAAW,EAAE;gDACb,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC;gDACtD,WAAO;6CACV;4CAED,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gDAClB,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gDAC5B,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;gDACrB,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;6CAC5B;4CACD,IAAI,CAAC,IAAI,EAAE;gDACP,WAAO;6CACV;4CAEG,OAAO,GAAG,UAAQ,CAAC,IAAI,CAAC,CAAC;iDACzB,CAAC,OAAO,EAAR,cAAQ;4CACQ,WAAM,0CAAsB,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,EAAA;;4CAAvD,OAAO,GAAG,SAA6C;4CAC7D,IAAI,CAAC,OAAO,EAAE;gDACV,KAAK,CAAC,yBAAyB,EAAE,OAAO,CAAC,CAAC;gDAC1C,WAAO;6CACV;4CACD,OAAO,GAAG,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC,eAAe,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;4CAC7E,UAAQ,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC;;;4CAGzB,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAY,CAAC,CAAC,CAAC,SAAS,CAAC;4CAClF,IAAI,CAAC,QAAQ,EAAE;gDAKX,QAAQ,GAAG,yBAAuB,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;6CAC/D;4CACD,IAAI,CAAC,QAAQ,EAAE;gDACX,WAAO;6CACV;4CACD,IAAI,QAAQ,CAAC,QAAQ,KAAK,MAAM,EAAE;gDAK9B,QAAQ,GAAG,yBAAuB,CAAC,QAAQ,CAAC,CAAC;6CAChD;4CACD,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,KAAK,MAAM,EAAE;gDAC3C,WAAO;6CACV;4CAEK,GAAG,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;4CACzC,IAAI,CAAC,GAAG,EAAE;gDACN,WAAO;6CACV;4CAID,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;;;;iCAC9C,CAAC;4BAEI,iBAAe,UAAO,KAAa;;;;;kDACb,EAAL,eAAK;;;iDAAL,CAAA,mBAAK,CAAA;4CAAb,IAAI;4CACX,WAAM,aAAW,CAAC,IAAI,CAAC,EAAA;;4CAAvB,SAAuB,CAAC;iDACpB,IAAI,CAAC,QAAQ,EAAb,cAAa;4CACb,WAAM,cAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAA;;4CAAjC,SAAiC,CAAC;;;4CAHvB,IAAK,CAAA;;;;;iCAM3B,CAAC;iCAEE,WAAW,CAAC,QAAQ,EAApB,eAAoB;kCACmB,EAApB,KAAA,WAAW,CAAC,QAAQ;;;iCAApB,CAAA,cAAoB,CAAA;4BAA5B,IAAI;4BACX,WAAM,aAAW,CAAC,IAAI,CAAC,EAAA;;4BAAvB,SAAuB,CAAC;;;4BADT,IAAoB,CAAA;;;iCAKvC,WAAW,CAAC,SAAS,EAArB,eAAqB;kCACmB,EAArB,KAAA,WAAW,CAAC,SAAS;;;iCAArB,CAAA,cAAqB,CAAA;4BAA7B,IAAI;4BACX,WAAM,aAAW,CAAC,IAAI,CAAC,EAAA;;4BAAvB,SAAuB,CAAC;;;4BADT,IAAqB,CAAA;;;iCAKxC,WAAW,CAAC,GAAG,EAAf,eAAe;4BACf,WAAM,cAAY,CAAC,WAAW,CAAC,GAAG,CAAC,EAAA;;4BAAnC,SAAmC,CAAC;;;4BAGlC,OAAO,GAAG,8BAAe,CAAC,WAAW,CAAC,CAAC;4BACvC,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;4BAC3D,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,eAAe,CAAC,CAAC;;;;4BAEzD,KAAK,CAAC,QAAM,CAAC,CAAC;;;4BAEd,SAAS,GAAG,UAAU,CAAC;gCACnB,SAAS,GAAG,SAAS,CAAC;gCACtB,MAAM,CAAC,2BAA2B,GAAG,aAAa,CAAC,CAAC;4BACxD,CAAC,EAAE,KAAK,CAAC,CAAC;4BACV,OAAO,CAAC,GAAG,EAAE,CAAC;;;;;iBAErB,CAAC,EAAC;;KACN,CAAC;AAlkDW,QAAA,2BAA2B,+BAkkDtC","sourcesContent":["// ==LICENSE-BEGIN==\n// Copyright 2017 European Digital Reading Lab. All rights reserved.\n// Licensed to the Readium Foundation under one or more contributor license agreements.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file exposed on Github (readium) in the project repository.\n// ==LICENSE-END==\n\nimport * as debug_ from \"debug\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as xmldom from \"xmldom\";\nimport * as xpath from \"xpath\";\nimport { ZipFile } from \"yazl\";\n\nimport { MediaOverlayNode } from \"@models/media-overlay\";\nimport { Metadata } from \"@models/metadata\";\nimport { Properties } from \"@models/metadata-properties\";\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { TaJsonDeserialize, TaJsonSerialize } from \"@r2-lcp-js/serializable\";\nimport { IZip } from \"@r2-utils-js/_utils/zip/zip\";\n\nimport {\n    lazyLoadMediaOverlays, loadFileBufferFromZipPath, loadFileStrFromZipPath, updateDurations,\n} from \"./epub-daisy-common\";\n\nconst debug = debug_(\"r2:shared#parser/daisy-convert-to-epub\");\n\nfunction ensureDirs(fspath: string) {\n    const dirname = path.dirname(fspath);\n\n    if (!fs.existsSync(dirname)) {\n        ensureDirs(dirname);\n        fs.mkdirSync(dirname);\n    }\n}\n\n// this function modifies the input parameter \"publication\"!\nexport const convertDaisyToReadiumWebPub = async (\n    outputDirPath: string, publication: Publication): Promise<string | undefined> => {\n\n    return new Promise(async (resolve, reject) => {\n\n        // dtb:multimediaContent ==> audio,text\n        const isFullTextAudio = publication.Metadata?.AdditionalJSON &&\n            publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioFullText\";\n\n        // dtb:multimediaContent ==> audio\n        const isAudioOnly = publication.Metadata?.AdditionalJSON &&\n            publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"audioNCX\";\n\n        // dtb:multimediaContent ==> text\n        const isTextOnly = publication.Metadata?.AdditionalJSON &&\n            publication.Metadata.AdditionalJSON[\"dtb:multimediaType\"] === \"textNCX\";\n\n        const zipInternal = publication.findFromInternal(\"zip\");\n        if (!zipInternal) {\n            debug(\"No publication zip!?\");\n            return reject(\"No publication zip!?\");\n        }\n        const zip = zipInternal.Value as IZip;\n\n        const outputZipPath = path.join(outputDirPath, `${isAudioOnly ? \"daisy_audioNCX\" : (isTextOnly ? \"daisy_textNCX\" : \"daisy_audioFullText\")}-to-epub.webpub`);\n        ensureDirs(outputZipPath);\n\n        let timeoutId: NodeJS.Timeout | undefined;\n        const zipfile = new ZipFile();\n        try {\n            const writeStream = fs.createWriteStream(outputZipPath);\n            zipfile.outputStream.pipe(writeStream)\n                .on(\"close\", () => {\n                    debug(\"ZIP close\");\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                        timeoutId = undefined;\n                        resolve(outputZipPath);\n                    }\n                })\n                .on(\"error\", (e: any) => {\n                    debug(\"ZIP error\", e);\n                    reject(e);\n                });\n\n            // <dtbook xmlns=\"http://www.daisy.org/z3986/2005/dtbook/\" ...\n            const select = xpath.useNamespaces({\n                dtbook: \"http://www.daisy.org/z3986/2005/dtbook/\",\n                // epub: \"http://www.idpf.org/2007/ops\",\n                // xhtml: \"http://www.w3.org/1999/xhtml\",\n            });\n\n            // http://www.daisy.org/z3986/structure/SG-DAISY3/index-of-elements.html\n            // a\n            // abbr\n            // acronym\n            // address\n            // annoref\n            // annotation\n            // author\n            // bdo\n            // blockquote\n            // bodymatter\n            // book\n            // br\n            // bridgehead\n            // byline\n            // caption\n            // cite\n            // code\n            // col\n            // colgroup\n            // covertitle\n            // dateline\n            // dd\n            // dfn\n            // div\n            // dl\n            // docauthor\n            // doctitle\n            // dt\n            // dtbook\n            // em\n            // epigraph\n            // frontmatter\n            // h1\n            // h2\n            // h3\n            // h4\n            // h5\n            // h6\n            // hd\n            // head\n            // img\n            // imggroup\n            // kbd\n            // level\n            // level1\n            // level2\n            // level3\n            // level4\n            // level5\n            // level6\n            // li\n            // lic\n            // line\n            // linegroup\n            // linenum\n            // link\n            // list\n            // meta\n            // note\n            // noteref\n            // p\n            // pagenum\n            // poem\n            // prodnote\n            // q\n            // rearmatter\n            // samp\n            // sent\n            // sidebar\n            // span\n            // strong\n            // sub\n            // sup\n            // table\n            // tbody\n            // td\n            // tfoot\n            // th\n            // thead\n            // title\n            // tr\n            // w\n\n            const elementNames = [\n                \"address\",\n                \"annoref\",\n                \"annotation\",\n                \"author\",\n                \"bdo\",\n                \"bodymatter\",\n                \"book\",\n                \"bridgehead\",\n                \"byline\",\n                \"caption\",\n                \"cite\",\n                \"col\",\n                \"colgroup\",\n                \"covertitle\",\n                \"dateline\",\n                \"dfn\",\n                \"docauthor\",\n                \"doctitle\",\n                \"dtbook\",\n                \"epigraph\",\n                \"frontmatter\",\n                \"hd\",\n                \"imggroup\",\n                \"kbd\",\n                \"level\",\n                \"levelhd\",\n                \"level1\",\n                \"level2\",\n                \"level3\",\n                \"level4\",\n                \"level5\",\n                \"level6\",\n                \"lic\",\n                \"line\",\n                \"linegroup\",\n                \"linenum\",\n                \"link\",\n                \"list\",\n                \"note\",\n                \"noteref\",\n                \"pagenum\",\n                \"poem\",\n                \"prodnote\",\n                \"rearmatter\",\n                \"samp\",\n                \"sent\",\n                \"sub\",\n                \"sup\",\n                \"q\",\n                \"w\",\n                \"notice\",\n                \"sidebar\",\n                \"blockquote\",\n                \"abbr\",\n                \"acronym\",\n                \"title\",\n            ];\n\n            interface TmoMap {\n                [smilTextRef: string]: {\n                    index: number,\n                    mos: MediaOverlayNode[],\n                };\n            }\n            let mediaOverlaysMap: TmoMap | undefined;\n\n            const getMediaOverlaysDuration = (mo: MediaOverlayNode): number => {\n                let duration: number = 0;\n\n                if (typeof mo.AudioClipBegin !== \"undefined\" &&\n                    typeof mo.AudioClipEnd !== \"undefined\") {\n\n                    duration = mo.AudioClipEnd - mo.AudioClipBegin;\n\n                } else if (mo.Children) {\n                    for (const child of mo.Children) {\n                        duration += getMediaOverlaysDuration(child);\n                    }\n                }\n\n                return duration;\n            };\n\n            const patchMediaOverlaysTextHref = (\n                mo: MediaOverlayNode,\n                audioOnlySmilHtmlHref: string | undefined): string | undefined => {\n\n                let smilTextRef: string | undefined;\n\n                if (audioOnlySmilHtmlHref && !mo.Text && mo.Audio) {\n                    smilTextRef = audioOnlySmilHtmlHref;\n                    mo.Text = `${smilTextRef}#${mo.ParID || \"_yyy_\"}`;\n                } else if (mo.Text) {\n                    // TODO: .xml file extension replacement is bit weak / brittle\n                    // (but for most DAISY books, this is a reasonable expectation)\n                    mo.Text = mo.Text.replace(/\\.xml/, \".xhtml\");\n                    smilTextRef = mo.Text;\n                    const k = smilTextRef.indexOf(\"#\");\n                    if (k > 0) {\n                        smilTextRef = smilTextRef.substr(0, k);\n                    }\n                }\n                if (mo.Children) {\n                    for (const child of mo.Children) {\n                        const smilTextRef_ = patchMediaOverlaysTextHref(child, audioOnlySmilHtmlHref);\n                        if (!smilTextRef_) {\n                            debug(\"########## WARNING: !smilTextRef ???!!\", smilTextRef_, child);\n                        } else if (smilTextRef && smilTextRef !== smilTextRef_) {\n                            debug(\"########## WARNING: smilTextRef !== smilTextRef_ ???!!\", smilTextRef, smilTextRef_);\n                        }\n                        if (!smilTextRef) {\n                            smilTextRef = smilTextRef_;\n                        }\n                    }\n                }\n\n                return smilTextRef;\n            };\n\n            // in-memory cache for expensive SMIL XML DOM parsing\n            const smilDocs: Record<string, Document> = {};\n\n            const findLinkInToc = (links: Link[], hrefDecoded: string): Link | undefined => {\n                for (const link of links) {\n                    if (link.HrefDecoded === hrefDecoded) {\n                        return link;\n                    } else if (link.Children) {\n                        const foundLink = findLinkInToc(link.Children, hrefDecoded);\n                        if (foundLink) {\n                            return foundLink;\n                        }\n                    }\n                }\n                return undefined;\n            };\n\n            const createHtmlFromSmilFile = async (smilPathInZip: string): Promise<string | undefined> => {\n\n                let smilDoc = smilDocs[smilPathInZip];\n                if (!smilDoc) {\n                    const smilStr = await loadFileStrFromZipPath(smilPathInZip, smilPathInZip, zip);\n                    if (!smilStr) {\n                        debug(\"!loadFileStrFromZipPath\", smilStr);\n                        return undefined;\n                    }\n                    smilDoc = new xmldom.DOMParser().parseFromString(smilStr, \"application/xml\");\n                    smilDocs[smilPathInZip] = smilDoc;\n                }\n\n                // getElementsByName(elementName: string): NodeListOf<HTMLElement>\n                // ==> not available in the XMLDOM API\n                // getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>\n                const parEls = Array.from(smilDoc.getElementsByTagName(\"par\"));\n                for (const parEl of parEls) {\n\n                    // getElementsByName(elementName: string): NodeListOf<HTMLElement>\n                    // ==> not available in the XMLDOM API\n                    // getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>\n                    const audioElements = Array.from(parEl.getElementsByTagName(\"audio\")).filter((el) => el);\n                    for (const audioElement of audioElements) {\n                        if (audioElement.parentNode) {\n                            audioElement.parentNode.removeChild(audioElement);\n                        }\n                    }\n\n                    const elmId = parEl.getAttribute(\"id\");\n                    const hrefDecoded = `${smilPathInZip}#${elmId}`;\n                    const tocLinkItem = findLinkInToc(publication.TOC, hrefDecoded);\n                    const text = tocLinkItem ? tocLinkItem.Title : undefined;\n\n                    const textNode = smilDoc.createTextNode(text ? text : \".\");\n                    parEl.appendChild(textNode);\n                }\n\n                const bodyContent = smilDoc.getElementsByTagName(\"body\")[0];\n                const bodyContentStr = new xmldom.XMLSerializer().serializeToString(bodyContent);\n                const contentStr = bodyContentStr\n                    .replace(`xmlns=\"http://www.w3.org/2001/SMIL20/\"`, \"\")\n                    .replace(/dur=/g, \"data-dur=\")\n                    .replace(/fill=/g, \"data-fill=\")\n                    .replace(/customTest=/g, \"data-customTest=\")\n                    .replace(/class=/g, \"data-class=\")\n                    .replace(/<seq/g, '<div class=\"smil-seq\"')\n                    .replace(/<par/g, '<p class=\"smil-par\"')\n                    .replace(/<\\/seq>/g, \"</div>\")\n                    .replace(/<\\/par>/g, \"</p>\")\n                    ;\n\n                const htmlDoc = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" xml:lang=\"en\" lang=\"en\">\n    <head>\n        <title>${smilPathInZip}</title>\n    </head>\n    ${contentStr}\n</html>\n`;\n                const htmlFilePath = smilPathInZip.replace(/\\.smil$/, \".xhtml\");\n                // const fileName = path.parse(href).name;\n                zipfile.addBuffer(Buffer.from(htmlDoc), htmlFilePath);\n                return htmlFilePath;\n            };\n\n            const audioOnlySmilHtmls: Link[] = [];\n            if (publication.Spine) {\n\n                mediaOverlaysMap = {};\n\n                let previousLinkItem: Link | undefined;\n                let spineIndex = -1;\n                for (const linkItem of publication.Spine) {\n                    spineIndex++;\n                    if (!linkItem.MediaOverlays) {\n                        continue;\n                    }\n\n                    if (!linkItem.MediaOverlays.initialized) {\n                        // mo.initialized true/false is automatically handled\n                        await lazyLoadMediaOverlays(publication, linkItem.MediaOverlays);\n\n                        if (isFullTextAudio || isAudioOnly) {\n                            updateDurations(linkItem.MediaOverlays.duration, linkItem);\n                        }\n                    }\n\n                    if (isFullTextAudio || isAudioOnly) {\n                        const computedDur = getMediaOverlaysDuration(linkItem.MediaOverlays);\n                        if (computedDur) {\n                            if (!linkItem.MediaOverlays.duration) {\n                                linkItem.MediaOverlays.duration = computedDur;\n\n                                updateDurations(computedDur, linkItem);\n                            } else {\n                                if (Math.round(linkItem.MediaOverlays.duration) !== Math.round(computedDur)) {\n                                    debug(\"linkItem.MediaOverlays.duration !== computedDur\",\n                                        linkItem.MediaOverlays.duration, computedDur);\n                                }\n                            }\n                        }\n\n                        if (previousLinkItem && previousLinkItem.MediaOverlays &&\n                            // !previousLinkItem.MediaOverlays.duration &&\n                            typeof previousLinkItem.MediaOverlays.totalElapsedTime !== \"undefined\" &&\n                            typeof linkItem.MediaOverlays.totalElapsedTime !== \"undefined\") {\n\n                            const dur = linkItem.MediaOverlays.totalElapsedTime -\n                                previousLinkItem.MediaOverlays.totalElapsedTime;\n                            if (dur > 0) {\n                                if (!previousLinkItem.MediaOverlays.duration) {\n                                    previousLinkItem.MediaOverlays.duration = dur;\n\n                                    updateDurations(dur, previousLinkItem);\n                                } else {\n                                    if (Math.round(previousLinkItem.MediaOverlays.duration) !== Math.round(dur)) {\n                                        debug(\"previousLinkItem.MediaOverlays.duration !== dur\",\n                                            previousLinkItem.MediaOverlays.duration, dur);\n                                    }\n                                }\n                            }\n                        }\n                        previousLinkItem = linkItem;\n                    }\n\n                    let smilTextRef: string | undefined;\n\n                    if (isAudioOnly) {\n                        const audioOnlySmilHtmlHref =\n                            linkItem.MediaOverlays.SmilPathInZip?.replace(/\\.smil$/, \".xhtml\");\n                        if (audioOnlySmilHtmlHref) {\n                            smilTextRef = patchMediaOverlaysTextHref(linkItem.MediaOverlays, audioOnlySmilHtmlHref);\n                        }\n                    } else {\n                        smilTextRef = patchMediaOverlaysTextHref(linkItem.MediaOverlays, undefined);\n                    }\n\n                    if (smilTextRef) {\n                        if (isAudioOnly && linkItem.MediaOverlays.SmilPathInZip) {\n                            await createHtmlFromSmilFile(linkItem.MediaOverlays.SmilPathInZip);\n\n                            const smilHtml = new Link();\n                            smilHtml.Href = smilTextRef;\n                            smilHtml.TypeLink = \"application/xhtml+xml\";\n                            audioOnlySmilHtmls.push(smilHtml);\n                        }\n\n                        // spineIndex++;\n                        if (!mediaOverlaysMap[smilTextRef]) {\n                            mediaOverlaysMap[smilTextRef] = {\n                                index: spineIndex,\n                                mos: [],\n                            };\n                        }\n                        // captures the last index in the reading order\n                        mediaOverlaysMap[smilTextRef].index = spineIndex;\n                        mediaOverlaysMap[smilTextRef].mos.push(linkItem.MediaOverlays);\n                    }\n                }\n            }\n            publication.Spine = [];\n\n            const resourcesToKeep: Link[] = [];\n\n            const dtBooks: Link[] = [...audioOnlySmilHtmls];\n            // reference copy! (not by value) so we can publication.Resources.push(...) safely within the loop\n            // const resources = [...publication.Resources];\n            // ... but we completely replace the array of Links, so this is fine:\n            for (const resLink of publication.Resources) {\n                // relative to publication root (package.opf / ReadiumWebPubManifest.json)\n                if (!resLink.HrefDecoded) {\n                    continue;\n                }\n                if (resLink.TypeLink === \"text/css\" || resLink.HrefDecoded.endsWith(\".css\")) {\n\n                    let cssText = await loadFileStrFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    if (!cssText) {\n                        debug(\"!loadFileStrFromZipPath\", resLink.HrefDecoded);\n                        continue;\n                    }\n\n                    // replace comments\n                    cssText = cssText.replace(/\\/\\*([\\s\\S]+?)\\*\\//gm, (_match, p1, _offset, _string) => {\n                        const base64 = Buffer.from(p1).toString(\"base64\");\n                        return `/*__${base64}__*/`;\n                    });\n\n                    // const regex = new RegExp(`[^#\\.](${elementNames.join(\"|\")})`, \"g\");\n                    for (const elementName of elementNames) {\n                        // meant to patch CSS selectors, but not property values\n                        const regex = new RegExp(\n                            `([^#\\.a-zA-Z0-9\\-_])(${elementName})([^a-zA-Z0-9\\-_;])`, \"g\");\n                        // let i = -1;\n                        // let match: RegExpExecArray | null;\n                        // // tslint:disable-next-line: no-conditional-assignment\n                        // while (match = regex.exec(cssText)) {\n                        //     i++;\n                        //     debug(\"A -----------\");\n                        //     debug(i, elementName, `$_$_$${match[0]}$_$_$`,\n                        // `===${match[1]}^^^${match[2]}^^^${match[3]}===`);\n                        //     debug(\"B -----------\");\n                        // }\n                        cssText = cssText.replace(regex, `$1.$2_R2$3`);\n\n                        // second pass, as the first doesn't match tokens with trailing / leading separators\n                        cssText = cssText.replace(regex, `$1.$2_R2$3`);\n                    }\n\n                    // restore comments\n                    cssText = cssText.replace(/\\/\\*__([\\s\\S]+?)__\\*\\//g, (_match, p1, _offset, _string) => {\n                        const comment = Buffer.from(p1, \"base64\").toString(\"utf8\");\n                        return `/*${comment}*/`;\n                    });\n\n                    // const newCssFilePath = resLink.HrefDecoded.replace(/\\.css$/, \"__.css\");\n                    // const cssOutputFilePath = path.join(outputDirPathExploded, newCssFilePath);\n                    // ensureDirs(cssOutputFilePath);\n                    // fs.writeFileSync(cssOutputFilePath, cssText);\n                    zipfile.addBuffer(Buffer.from(cssText), resLink.HrefDecoded);\n\n                    // const resLinkJson = TaJsonSerialize(resLink);\n                    // // resLinkJson.href = newCssFilePath;\n                    // const resLinkClone = TaJsonDeserialize<Link>(resLinkJson, Link);\n                    // resLinkClone.setHrefDecoded(newCssFilePath);\n\n                    resourcesToKeep.push(resLink);\n\n                } else if (resLink.TypeLink === \"application/x-dtbook+xml\" || resLink.HrefDecoded.endsWith(\".xml\")) {\n\n                    // TODO: XSLT?\n                    /*\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--******************************\nDAISY XSL TRANSFORM\n\nMake an XSL capable browser\nunderstand DAISY markup.\n****************************** -->\n\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\nxmlns:dtb=\"http://www.daisy.org/z3986/2005/dtbook/\">\n\n<xsl:output method=\"html\" indent=\"no\"/>\n\n<!--******************************\nDOCBOOK, HEAD, META, LINK, BOOK\n*******************************-->\n\n<!-- docbook translates to html -->\n<xsl:template match=\"dtb:dtbook\">\n<html><xsl:apply-templates/></html>\n</xsl:template>\n\n<!-- head maps directly -->\n<xsl:template match=\"dtb:head\">\n<xsl:element name=\"head\">\n<xsl:if test=\"@profile\">\n<xsl:attribute name=\"profile\"><xsl:value-of select=\"@profile\"/></xsl:attribute>\n</xsl:if>\n\n<title><xsl:value-of select=\"/dtb:dtbook/dtb:book/dtb:frontmatter/dtb:doctitle\"/></title>\n\n<link rel=\"stylesheet\" type=\"text/css\" href=\"html.css\" />\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- meta maps directly\nInclude: content\nIf applicable, include: http-equiv, name\nNOTE: meta contains no content so no apply-templates necessary -->\n<xsl:template match=\"dtb:meta\">\n<xsl:element name=\"meta\">\n<xsl:if test=\"@http-equiv\">\n<xsl:attribute name=\"http-equiv\"><xsl:value-of select=\"@http-equiv\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@name\">\n<xsl:attribute name=\"name\"><xsl:value-of select=\"@name\"/></xsl:attribute>\n</xsl:if>\n<xsl:attribute name=\"content\"><xsl:value-of select=\"@content\"/></xsl:attribute>\n</xsl:element>\n</xsl:template>\n\n<!-- link maps directly\nIf aqpplicable, includes: charset, href, hreflang, media, rel, rev, type\nNOTE: link contains no content so no apply-templates necessary -->\n<xsl:template match=\"dtb:link\">\n<xsl:element name=\"link\">\n<xsl:call-template name=\"link-attributes\"/>\n<xsl:if test=\"@media\">\n<xsl:attribute name=\"media\"><xsl:value-of select=\"@media\"/></xsl:attribute>\n</xsl:if>\n</xsl:element>\n</xsl:template>\n\n<!-- book should be translated to body -->\n<xsl:template match=\"dtb:book\">\n<body>\n<xsl:call-template name=\"segmentedNav\"/>\n<xsl:apply-templates/>\n<xsl:call-template name=\"segmentedNav\"/>\n</body>\n</xsl:template>\n\n<!-- inter-DTBook navigation -->\n<xsl:template name=\"segmentedNav\">\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel!='']\">\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel='start']\">\n<xsl:variable name=\"sn\" select=\"/dtb:dtbook/dtb:head/dtb:link[@rel='start']\"/>\n<xsl:element name=\"a\">\n<xsl:attribute name=\"href\">\n<xsl:choose>\n<xsl:when test=\"$sn/@href\"><xsl:value-of select=\"$sn/@href\"/></xsl:when>\n<xsl:otherwise><xsl:value-of select=\"$sn/@resource\"/></xsl:otherwise>\n</xsl:choose>\n</xsl:attribute>\n<xsl:text>Start</xsl:text>\n</xsl:element>\n</xsl:if>\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel='prev']\">\n<xsl:variable name=\"pn\" select=\"/dtb:dtbook/dtb:head/dtb:link[@rel='prev']\"/>\n<xsl:text> | </xsl:text>\n<xsl:element name=\"a\">\n<xsl:attribute name=\"href\">\n<xsl:choose>\n<xsl:when test=\"$pn/@href\"><xsl:value-of select=\"$pn/@href\"/></xsl:when>\n<xsl:otherwise><xsl:value-of select=\"$pn/@resource\"/></xsl:otherwise>\n</xsl:choose>\n</xsl:attribute>\n<xsl:text>Previous</xsl:text>\n</xsl:element>\n</xsl:if>\n<xsl:if test=\"/dtb:dtbook/dtb:head/dtb:link[@rel='next']\">\n<xsl:variable name=\"nn\" select=\"/dtb:dtbook/dtb:head/dtb:link[@rel='next']\"/>\n<xsl:text> | </xsl:text>\n<xsl:element name=\"a\">\n<xsl:attribute name=\"href\">\n<xsl:choose>\n<xsl:when test=\"$nn/@href\"><xsl:value-of select=\"$nn/@href\"/></xsl:when>\n<xsl:otherwise><xsl:value-of select=\"$nn/@resource\"/></xsl:otherwise>\n</xsl:choose>\n</xsl:attribute>\n<xsl:text>Next</xsl:text>\n</xsl:element>\n</xsl:if>\n</xsl:if>\n</xsl:template>\n\n<!--*******************************\nFRONTMATTER, BODYMATTER, REARMATTER\n******************************* -->\n\n<!--frontmatter, bodymatter and rearmatter become divisions with appropriate class attributes-->\n<xsl:template match=\"dtb:frontmatter | dtb:bodymatter | dtb:rearmatter\">\n<xsl:element name=\"div\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--**************************\nDOCTITLE, DOCAUTHOR, COVERTITLE\n***************************-->\n\n<!-- doctitle is h1 with class for styling -->\n<xsl:template match=\"dtb:doctitle\">\n<h1 class=\"doctitle\"><xsl:apply-templates/></h1>\n</xsl:template>\n\n<!-- docauthor is p with class for styling -->\n<xsl:template match=\"dtb:docauthor\">\n<p class=\"docauthor\"><xsl:apply-templates/></p>\n</xsl:template>\n\n<!-- covertitle is p with class for styling -->\n<xsl:template match=\"dtb:covertitle\">\n<p class=\"covertitle\"><xsl:apply-templates/></p>\n</xsl:template>\n\n<!--***********************\nLEVELS\n************************-->\n\n<!-- Levels map to div with class -->\n<xsl:template match=\"dtb:level | dtb:level1 | dtb:level2 | dtb:level3 | dtb:level4 | dtb:level5 | dtb:level6\">\n<xsl:element name=\"div\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--***********************\nHEADINGS\n************************-->\n\n<!--h1...h6 map directly -->\n<xsl:template match=\"dtb:h1 | dtb:h2 | dtb:h3 | dtb:h4 | dtb:h5 | dtb:h6\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!-- hd as child of level converts to h1...h6 based on number of level ancestors\nIf more than 6 ancestors then defaults to h6, flattening hierarchy beyond level 6 -->\n<xsl:template match=\"dtb:level/dtb:hd\">\n<xsl:variable name=\"levelDepth\" select=\"count(ancestor-or-self::dtb:level)\" />\n<xsl:choose>\n<xsl:when test=\"$levelDepth &lt;= 6\">\n<xsl:element name=\"{concat('h',$levelDepth)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:when>\n<xsl:otherwise>\n<xsl:element name=\"h6\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\n\n<!--for hd within items like list use paragraph with class -->\n<!-- for bridgehead use paragraph with class -->\n<xsl:template match=\"dtb:hd | dtb:bridgehead\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nPAGENUM, LINENUM\n************************-->\n\n<!--Put the pagenum into a paragraph element if the parent is level or level1...level6 otherwise put it into a span\nUse the pagenum class for formatting -->\n<xsl:template match=\"dtb:pagenum\">\n<xsl:choose>\n<xsl:when test=\"parent::dtb:level or parent::dtb:level1 or parent::dtb:level2 or\nparent::dtb:level3 or parent::dtb:level4 or parent::dtb:level5 or parent::dtb:level6\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:when>\n<xsl:otherwise>\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\n\n<!-- linenum is translated to span with class -->\n<xsl:template match=\"dtb:linenum\">\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nGENERAL BLOCKS\n************************-->\n\n<!-- address, div, p map directly -->\n<xsl:template match=\"dtb:address | dtb:div | dtb:p\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!-- annotation, epigraph, linegroup, note, poem, prodnote, sidebar map to div with class\nFor prodnote, sidebar: Exclude: render attribute, no way to express -->\n<xsl:template\nmatch=\"dtb:annotation | dtb:epigraph | dtb:linegroup | dtb:note | dtb:poem | dtb:prodnote | dtb:sidebar\">\n<xsl:element name=\"div\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!-- blockquote maps directly\nIf applicable, include: cite -->\n<xsl:template match=\"dtb:blockquote\">\n<xsl:element name=\"blockquote\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:if test=\"@cite\">\n<xsl:attribute name=\"cite\"><xsl:value-of select=\"@cite\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- byline, dateline, line maps to a p with class -->\n<xsl:template match=\"dtb:byline | dtb:dateline | dtb:line\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n<xsl:apply-templates />\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nGENERAL INLINES\n************************-->\n\n<!-- a maps directly\nIf applicable, include: charset, href, hreflang, rel, rev, type\nIf external is true then target a new window -->\n<xsl:template match=\"dtb:a\">\n<xsl:element name=\"a\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"link-attributes\"/>\n<xsl:if test=\"@external='true'\">\n<xsl:attribute name=\"target\">_blank</xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- bdo maps directly,\nInclude: dir -->\n<xsl:template match=\"dtb:bdo\">\n<bdo dir=\"{@dir}\"><xsl:apply-templates/></bdo>\n</xsl:template>\n\n<!-- abbr, acronym, cite, dfn, em, kbd, samp, strong, sub, sup map directly -->\n<xsl:template\nmatch=\"dtb:abbr | dtb:acronym | dtb:cite | dtb:dfn | dtb:em | dtb:kbd | dtb:samp | dtb:strong | dtb:sub | dtb:sup\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- code maps directly\nIf has class preserve-whitespace then surround with a pre tag -->\n<xsl:template match=\"dtb:code\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:choose>\n<xsl:when test=\"@class='preserve-whitespace'\">\n<xsl:element name=\"pre\"><xsl:apply-templates/></xsl:element>\n</xsl:when>\n<xsl:otherwise>\n<xsl:apply-templates/>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:element>\n</xsl:template>\n\n<!-- span maps to span for classes underline, strikethrough,\ndouble-strikethrough, small-caps, but is omitted otherwise -->\n<xsl:template match=\"dtb:span\">\n<xsl:choose>\n<xsl:when test=\"@class='underline'\">\n<span class=\"underline\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:when test=\"@class='strikethrough'\">\n<span class=\"strikethrough\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:when test=\"@class='double-strikethrough'\">\n<span class=\"double-strikethrough\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:when test=\"@class='small-caps'\">\n<span class=\"small-caps\"><xsl:apply-templates/></span>\n</xsl:when>\n<xsl:otherwise>\n<xsl:apply-templates/>\n</xsl:otherwise>\n</xsl:choose>\n</xsl:template>\n\n<!--title-->\n\n<!-- author maps to p with class -->\n<xsl:template match=\"dtb:author\">\n<xsl:element name=\"p\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\"/></xsl:attribute>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- br maps directly\nNOTE: no apply-templates needed since this tag is always self closing-->\n<xsl:template match=\"dtb:br\">\n<br />\n</xsl:template>\n\n<!-- q maps directly\nIf applicable, includes: cite -->\n<xsl:template match=\"dtb:q\">\n<xsl:element name=\"q\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:if test=\"@cite\">\n<xsl:attribute name=\"cite\"><xsl:value-of select=\"@cite\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- annoref, noteref maps to span with class -->\n<xsl:template match=\"dtb:annoref | dtb:noteref\">\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\" /></xsl:attribute>\n</xsl:element>\n</xsl:template>\n\n<!-- sent, w have no equivalent tag -->\n<xsl:template match=\"dtb:sent | dtb:w\">\n<xsl:apply-templates/>\n</xsl:template>\n\n<!--*************************\nLISTS\n************************-->\n\n<!--Get fancy with the various list types-->\n\n<!-- An unordered list will be wrapped in ul tags -->\n<xsl:template match=\"dtb:list[@type='ul']\">\n<xsl:element name=\"ul\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- A preformatted list will be wrapped in ul tags with an appropriate class.\nCSS can be used to turn off default display symbols, the list will still be\nrendered as such in the browser's DOM, which will let screen readers\nannounce the item as a list -->\n<xsl:template match=\"dtb:list[@type='pl']\">\n<xsl:element name=\"ul\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\">pl</xsl:attribute>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- An ordered list will be wrapped in ol tags\nEnsure the desired formatting is preserved by pushing the enum attribute into the class attribute\nNote: replaces enum=\"1\" with class=\"one\" to ensure CSS 2.1 validation\nIf applicable, include: start -->\n<xsl:template match=\"dtb:list[@type='ol']\">\n<xsl:element name=\"ol\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:choose>\n<xsl:when test=\"@enum='1'\">\n<xsl:attribute name=\"class\">one</xsl:attribute>\n</xsl:when>\n<xsl:otherwise>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"@enum\"/></xsl:attribute>\n</xsl:otherwise>\n</xsl:choose>\n<xsl:if test=\"@start\">\n<xsl:attribute name=\"start\"><xsl:value-of select=\"@start\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- li maps directly -->\n<xsl:template match=\"dtb:li\">\n<xsl:element name=\"li\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- lic maps to span -->\n<xsl:template match=\"dtb:lic\">\n<xsl:element name=\"span\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"class\"><xsl:value-of select=\"local-name(.)\"/></xsl:attribute>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- *************************\nDEFINITION LIST\n************************ -->\n\n<!-- dd, dl, dt map directly -->\n<xsl:template match=\"dtb:dd | dtb:dl | dtb:dt\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nTABLES\n************************ *** -->\n\n<!-- table maps directly\nIf applicable, include: border, cellpadding, cellspacing, frame, rules, summary, width -->\n<xsl:template match=\"dtb:table\">\n<xsl:element name=\"table\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:if test=\"@border\">\n<xsl:attribute name=\"border\"><xsl:value-of select=\"@border\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@cellpadding\">\n<xsl:attribute name=\"cellpadding\"><xsl:value-of select=\"@cellpadding\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@cellspacing\">\n<xsl:attribute name=\"cellspacing\"><xsl:value-of select=\"@cellspacing\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@frame\">\n<xsl:attribute name=\"frame\"><xsl:value-of select=\"@frame\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rules\">\n<xsl:attribute name=\"rules\"><xsl:value-of select=\"@rules\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@summary\">\n<xsl:attribute name=\"summary\"><xsl:value-of select=\"@summary\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@width\">\n<xsl:attribute name=\"width\"><xsl:value-of select=\"@width\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- table/caption maps directly -->\n<xsl:template match=\"dtb:table/dtb:caption\">\n<xsl:element name=\"caption\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- tr maps directly\nIf applicable, include: align, char, charoff, valign -->\n<xsl:template match=\"dtb:tr\">\n<xsl:element name=\"tr\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- col, colgroup map directly\nIf applicable, include: align, char, charoff, span, valign, width -->\n<xsl:template match=\"dtb:col | dtb:colgroup\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:if test=\"@span\">\n<xsl:attribute name=\"span\"><xsl:value-of select=\"@span\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@width\">\n<xsl:attribute name=\"width\"><xsl:value-of select=\"@width\"/></xsl:attribute>\n</xsl:if>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- tbody, thead, tfoot map directly\nIf applicable, include: align, char, charoff, valign -->\n<xsl:template match=\"dtb:tbody | dtb:thead | dtb:tfoot\">\n<xsl:element name=\"{local-name(.)}\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!-- td, th map directly\nIf applicable, include: abbr, align, axis, char, charoff, colspan, headers, rowspan, scope, valign -->\n<xsl:template match=\"dtb:td | dtb:th\">\n<xsl:element name=\"td\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:call-template name=\"alignment-attributes\"/>\n<xsl:if test=\"@abbr\">\n<xsl:attribute name=\"abbr\"><xsl:value-of select=\"@abbr\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@axis\">\n<xsl:attribute name=\"axis\"><xsl:value-of select=\"@axis\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@colspan\">\n<xsl:attribute name=\"colspan\"><xsl:value-of select=\"@colspan\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@headers\">\n<xsl:attribute name=\"headers\"><xsl:value-of select=\"@headers\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rowspan\">\n<xsl:attribute name=\"rowspan\"><xsl:value-of select=\"@rowspan\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@scope\">\n<xsl:attribute name=\"scope\"><xsl:value-of select=\"@scope\"/></xsl:attribute>\n</xsl:if>\n\n<xsl:apply-templates/>\n</xsl:element>\n</xsl:template>\n\n<!--*************************\nIMAGES\n************************ *** -->\n\n<!-- img maps directly\nInclude: alt, src\nIf applicable, include: longdesc, height, width\nNOTE: img is self closing so no apply-templates necessary -->\n<xsl:template match=\"dtb:img\">\n<xsl:element name=\"img\">\n<xsl:call-template name=\"base-attributes\"/>\n<xsl:attribute name=\"alt\"><xsl:value-of select=\"@alt\"/></xsl:attribute>\n<xsl:attribute name=\"src\"><xsl:value-of select=\"@src\"/></xsl:attribute>\n<xsl:if test=\"@longdesc\">\n<xsl:attribute name=\"longdesc\"><xsl:value-of select=\"@longdesc\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@height\">\n<xsl:attribute name=\"height\"><xsl:value-of select=\"@height\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@width\">\n<xsl:attribute name=\"width\"><xsl:value-of select=\"@width\"/></xsl:attribute>\n</xsl:if>\n</xsl:element>\n</xsl:template>\n\n<!-- imggroup maps to div with class -->\n<xsl:template match=\"dtb:imggroup\">\n<div class=\"imggroup\"><xsl:apply-templates/></div>\n</xsl:template>\n\n<!-- imggroup/caption maps to div with class\nExcludes imgref - no way to express -->\n<xsl:template match=\"dtb:imggroup/dtb:caption\">\n<div class=\"caption\"><xsl:apply-templates/></div>\n</xsl:template>\n\n<!--*************************\nHelpers\n************************ *** -->\n\n<!-- If applicable include id -->\n<xsl:template name=\"base-attributes\">\n<xsl:if test=\"@id\">\n<xsl:attribute name=\"id\"><xsl:value-of select=\"@id\"/></xsl:attribute>\n</xsl:if>\n</xsl:template>\n\n<!-- If applicable include align, char, charoff, valign -->\n<xsl:template name=\"alignment-attributes\">\n<xsl:if test=\"@align\">\n<xsl:attribute name=\"align\"><xsl:value-of select=\"@align\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@char\">\n<xsl:attribute name=\"char\"><xsl:value-of select=\"@char\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@charoff\">\n<xsl:attribute name=\"charoff\"><xsl:value-of select=\"@charoff\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@valign\">\n<xsl:attribute name=\"valign\"><xsl:value-of select=\"@valign\"/></xsl:attribute>\n</xsl:if>\n</xsl:template>\n\n<!-- If applicable include: charset, href, hreflang, rel, rev, type -->\n<xsl:template name=\"link-attributes\">\n<xsl:if test=\"@charset\">\n<xsl:attribute name=\"charset\"><xsl:value-of select=\"@charset\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@href\">\n<xsl:attribute name=\"href\"><xsl:value-of select=\"@href\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@hreflang\">\n<xsl:attribute name=\"hreflang\"><xsl:value-of select=\"@hreflang\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rel\">\n<xsl:attribute name=\"rel\"><xsl:value-of select=\"@rel\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@rev\">\n<xsl:attribute name=\"rev\"><xsl:value-of select=\"@rev\"/></xsl:attribute>\n</xsl:if>\n<xsl:if test=\"@type\">\n<xsl:attribute name=\"type\"><xsl:value-of select=\"@type\"/></xsl:attribute>\n</xsl:if>\n</xsl:template>\n\n</xsl:stylesheet>\n                    */\n                    let dtBookStr = await loadFileStrFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    if (!dtBookStr) {\n                        debug(\"!loadFileStrFromZipPath\", dtBookStr);\n                        continue;\n                    }\n                    dtBookStr = dtBookStr.replace(/xmlns=\"\"/, \" \");\n                    dtBookStr = dtBookStr.replace(/<dtbook/, \"<dtbook xmlns:epub=\\\"http://www.idpf.org/2007/ops\\\" \");\n                    const dtBookDoc = new xmldom.DOMParser().parseFromString(dtBookStr, \"application/xml\");\n\n                    let title = dtBookDoc.getElementsByTagName(\"doctitle\")[0]?.textContent;\n                    if (title) {\n                        title = title.trim();\n                        if (!title.length) {\n                            title = null;\n                        }\n                    }\n\n                    const listElements = dtBookDoc.getElementsByTagName(\"list\");\n                    for (let i = 0; i < listElements.length; i++) {\n                        const listElement = listElements.item(i);\n                        if (!listElement) {\n                            continue;\n                        }\n                        const type = listElement.getAttribute(\"type\");\n                        if (type) {\n                            // TODO: strictly-speaking, this is a read-only property!\n                            (listElement as any).tagName = type;\n                            // listElement.removeAttribute(\"type\");\n                        }\n                    }\n\n                    //             .replace(/(<\\/?)imggroup/g, \"$1figure\")\n                    //             .replace(/<caption/g, \"<figcaption\")\n                    //             .replace(/<\\/caption>/g, \"</figcaption>\");\n\n                    for (const elementName of elementNames) {\n                        // getElementsByName(elementName: string): NodeListOf<HTMLElement>\n                        // ==> not available in the XMLDOM API\n                        // getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>\n                        // ==> mutates during loop because of tagName reassignment!\n                        const els = Array.from(dtBookDoc.getElementsByTagName(elementName)).filter((el) => el);\n                        for (const el of els) {\n                            el.setAttribute(\"data-dtbook\", elementName);\n                            const cls = el.getAttribute(\"class\");\n                            el.setAttribute(\"class\", `${cls ? (cls + \" \") : \"\"}${elementName}_R2`);\n                            // TODO: strictly-speaking, this is a read-only property!\n                            (el as any).tagName =\n                                ((elementName === \"dtbook\") ? \"html\" :\n                                    ((elementName === \"book\") ? \"body\" :\n                                        ((elementName === \"pagenum\") ? \"span\" :\n                                            ((elementName === \"sent\") ? \"span\" :\n                                                ((elementName === \"caption\") ? \"figcaption\" :\n                                                    ((elementName === \"imggroup\") ? \"figure\" :\n                                                        (elementName === \"sidebar\") ? \"aside\" :\n                                                            \"div\"))))));\n                            if (elementName === \"pagenum\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"pagebreak\");\n                                el.setAttribute(\"epub:type\", \"pagebreak\");\n                            } else if (elementName === \"annotation\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"annotation\");\n                                el.setAttribute(\"epub:type\", \"annotation\");\n                            } else if (elementName === \"note\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"note\");\n                                el.setAttribute(\"epub:type\", \"note\");\n                            } else if (elementName === \"prodnote\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"note\");\n                                el.setAttribute(\"epub:type\", \"note\");\n                            } else if (elementName === \"sidebar\") {\n                                // el.setAttributeNS(\"http://www.idpf.org/2007/ops\", \"type\", \"sidebar\");\n                                el.setAttribute(\"epub:type\", \"sidebar\");\n                            }\n                        }\n                    }\n\n                    // <?xml-stylesheet type=\"text/css\" href=\"dtbookbasic.css\"?>\n                    const stylesheets =\n                        select(\"/processing-instruction('xml-stylesheet')\", dtBookDoc) as ProcessingInstruction[];\n                    const cssHrefs: string[] = []; // `<link rel=\"stylesheet\" href=\"${cssHref}\" />`\n                    for (const stylesheet of stylesheets) {\n                        if (!stylesheet.nodeValue) {\n                            continue;\n                        }\n                        if (!stylesheet.nodeValue.includes(\"text/css\")) {\n                            continue;\n                        }\n                        const match = stylesheet.nodeValue.match(/href=(\"|')(.*?)(\"|')/);\n                        if (!match) {\n                            continue;\n                        }\n                        const href = match[2].trim();\n                        if (href) {\n                            cssHrefs.push(href);\n                        }\n                    }\n\n                    const smilRefs = select(\"//*[@smilref]\", dtBookDoc) as Element[];\n                    for (const smilRef of smilRefs) {\n                        const ref = smilRef.getAttribute(\"smilref\");\n                        if (ref) {\n                            smilRef.setAttribute(\"data-smilref\", ref);\n                        }\n                        smilRef.removeAttribute(\"smilref\");\n                    }\n\n                    // does not work (element renamed via the tagName assignment still have the original NameSpaceURI,\n                    // which gets serialized)\n                    // dtBookDoc.documentElement.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n\n                    // does not work (read only property):\n                    // (dtBookDoc as any).doctype = null;\n                    // ...so we use regexp replace below\n\n                    const dtbookNowXHTML = new xmldom.XMLSerializer().serializeToString(dtBookDoc)\n                        .replace(/xmlns=\"http:\\/\\/www\\.daisy\\.org\\/z3986\\/2005\\/dtbook\\/\"/, \"xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\")\n                        .replace(/xmlns=\"http:\\/\\/www\\.daisy\\.org\\/z3986\\/2005\\/dtbook\\/\"/g, \" \")\n                        .replace(/^([\\s\\S]*)<html/gm,\n                            `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html `)\n                        .replace(/<head([\\s\\S]*?)>/gm,\n                            `\n<head$1>\n<meta charset=\"UTF-8\" />\n${title ? `<title>${title}</title>` : \"\"}\n`)\n                        .replace(/<\\/head[\\s\\S]*?>/gm,\n                            `\n${cssHrefs.reduce((pv, cv) => {\n                                return pv + \"\\n\" + `<link rel=\"stylesheet\" type=\"text/css\" href=\"${cv}\" />`;\n                            }, \"\")}\n</head>\n`);\n                    const xhtmlFilePath = resLink.HrefDecoded.replace(/\\.(.+)$/, \".xhtml\");\n\n                    // const xhtmlOutputFilePath = path.join(outputDirPathExploded, xhtmlFilePath);\n                    // ensureDirs(xhtmlOutputFilePath);\n                    // fs.writeFileSync(xhtmlOutputFilePath, dtbookNowXHTML);\n                    // zipfile.addFile(xhtmlOutputFilePath, xhtmlFilePath);\n                    zipfile.addBuffer(Buffer.from(dtbookNowXHTML), xhtmlFilePath);\n\n                    const resLinkJson = TaJsonSerialize(resLink);\n                    // resLinkJson.href = xhtmlFilePath;\n                    const resLinkClone = TaJsonDeserialize<Link>(resLinkJson, Link);\n                    resLinkClone.setHrefDecoded(xhtmlFilePath);\n                    resLinkClone.TypeLink = \"application/xhtml+xml\";\n\n                    dtBooks.push(resLinkClone);\n\n                } else if (!resLink.HrefDecoded.endsWith(\".opf\") &&\n                    !resLink.HrefDecoded.endsWith(\".res\") &&\n                    !resLink.HrefDecoded.endsWith(\".ncx\")) {\n\n                    const buff = await loadFileBufferFromZipPath(resLink.Href, resLink.HrefDecoded, zip);\n                    if (buff) {\n                        zipfile.addBuffer(buff, resLink.HrefDecoded);\n                    }\n\n                    resourcesToKeep.push(resLink);\n                }\n            }\n\n            if (mediaOverlaysMap) {\n                Object.keys(mediaOverlaysMap).forEach((smilTextRef) => {\n                    if (!mediaOverlaysMap) { // compiler check\n                        return;\n                    }\n                    debug(\"smilTextRef: \" + smilTextRef);\n                    const mos = mediaOverlaysMap[smilTextRef].mos;\n                    if (mos.length === 1) { // single-item array\n                        debug(\"smilTextRef [1]: \" + smilTextRef);\n                        return;\n                    }\n\n                    const mergedMediaOverlays = new MediaOverlayNode();\n                    mergedMediaOverlays.SmilPathInZip = undefined;\n                    mergedMediaOverlays.initialized = true;\n                    mergedMediaOverlays.Role = [];\n                    mergedMediaOverlays.Role.push(\"section\");\n                    mergedMediaOverlays.duration = 0;\n\n                    let i = -1;\n                    for (const mo of mos) {\n                        i++;\n                        if (mo.Children) {\n                            debug(`smilTextRef [${i}]: ` + smilTextRef);\n\n                            if (!mergedMediaOverlays.Children) {\n                                mergedMediaOverlays.Children = [];\n                            }\n                            mergedMediaOverlays.Children = mergedMediaOverlays.Children.concat(mo.Children);\n\n                            if (mo.duration) {\n                                mergedMediaOverlays.duration += mo.duration;\n                            }\n                        }\n                    }\n                    mediaOverlaysMap[smilTextRef].mos = [mergedMediaOverlays]; // single-item array\n                });\n\n                const mediaOverlaysSequence = Object.keys(mediaOverlaysMap).map((smilTextRef) => {\n                    if (!mediaOverlaysMap) { // compiler check\n                        return undefined;\n                    }\n                    return {\n                        index: mediaOverlaysMap[smilTextRef].index,\n                        mo: mediaOverlaysMap[smilTextRef].mos[0], // single-item array, at this point\n                        smilTextRef,\n                    };\n                }).filter((e) => e).sort((a, b) => {\n                    // a less than b\n                    if (a && b && a.index < b.index) {\n                        return -1;\n                    }\n                    // a more than b\n                    if (a && b && a.index > b.index) {\n                        return 1;\n                    }\n                    // a === b\n                    return 0;\n                });\n\n                for (const mediaOverlay of mediaOverlaysSequence) {\n                    if (!mediaOverlay) { // compiler check\n                        continue;\n                    }\n                    debug(\"mediaOverlay:\", mediaOverlay.index, mediaOverlay.smilTextRef);\n\n                    const dtBookLink = dtBooks.find((l) => {\n                        return l.HrefDecoded === mediaOverlay.smilTextRef;\n                    });\n\n                    if (!dtBookLink) {\n                        debug(\"!!dtBookLink\");\n                    } else if (dtBookLink.HrefDecoded !== mediaOverlay.smilTextRef) {\n                        debug(\"dtBook.HrefDecoded !== mediaOverlay.smilTextRef\",\n                            dtBookLink.HrefDecoded, mediaOverlay.smilTextRef);\n                    } else {\n                        if (isFullTextAudio || isAudioOnly) {\n                            dtBookLink.MediaOverlays = mediaOverlay.mo;\n\n                            if (mediaOverlay.mo.duration) {\n                                dtBookLink.Duration = mediaOverlay.mo.duration;\n                            }\n\n                            const moURL = `smil-media-overlays_${mediaOverlay.index}.json`;\n                            // mediaOverlayURLPath + \"?\" +\n                            //     mediaOverlayURLParam + \"=\" +\n                            //     encodeURIComponent_RFC3986(\n                            //         resLinkClone.HrefDecoded ? resLinkClone.HrefDecoded : resLinkClone.Href);\n\n                            // legacy method:\n                            if (!dtBookLink.Properties) {\n                                dtBookLink.Properties = new Properties();\n                            }\n                            dtBookLink.Properties.MediaOverlay = moURL;\n\n                            // new method:\n                            // tslint:disable-next-line: max-line-length\n                            // https://w3c.github.io/sync-media-pub/incorporating-synchronized-narration.html#with-webpub\n                            if (!dtBookLink.Alternate) {\n                                dtBookLink.Alternate = [];\n                            }\n                            const moLink = new Link();\n                            moLink.Href = moURL;\n                            moLink.TypeLink = \"application/vnd.syncnarr+json\";\n                            moLink.Duration = dtBookLink.Duration;\n                            dtBookLink.Alternate.push(moLink);\n\n                            const jsonObjMO = TaJsonSerialize(mediaOverlay.mo);\n                            const jsonStrMO = global.JSON.stringify(jsonObjMO, null, \"  \");\n                            zipfile.addBuffer(Buffer.from(jsonStrMO), moURL);\n\n                            debug(\"dtBookLink IN SPINE:\",\n                                mediaOverlay.index, dtBookLink.HrefDecoded, dtBookLink.Duration, moURL);\n                        } else {\n                            debug(\"dtBookLink IN SPINE (no audio):\", mediaOverlay.index, dtBookLink.HrefDecoded);\n                        }\n                        publication.Spine.push(dtBookLink);\n                    }\n                }\n            }\n\n            publication.Resources = resourcesToKeep;\n\n            if (!publication.Metadata) {\n                publication.Metadata = new Metadata();\n            }\n            // publication.Metadata.Source = \"DAISY\";\n            if (!publication.Metadata.AdditionalJSON) {\n                publication.Metadata.AdditionalJSON = {};\n            }\n            publication.Metadata.AdditionalJSON.ReadiumWebPublicationConvertedFrom =\n                isAudioOnly ? \"DAISY_audioNCX\" : (isTextOnly ? \"DAISY_textNCX\" : \"DAISY_audioFullText\");\n\n            const findFirstDescendantText = (parent: Element): Element | undefined => {\n                if (parent.childNodes && parent.childNodes.length) {\n                    // tslint:disable-next-line: prefer-for-of\n                    for (let i = 0; i < parent.childNodes.length; i++) {\n                        const child = parent.childNodes[i];\n                        if (child.nodeType === 1) { // Node.ELEMENT_NODE\n                            const element = child as Element;\n                            if (element.localName && element.localName.toLowerCase() === \"text\") {\n                                return element;\n                            }\n                        }\n                    }\n                    // tslint:disable-next-line: prefer-for-of\n                    for (let i = 0; i < parent.childNodes.length; i++) {\n                        const child = parent.childNodes[i];\n                        if (child.nodeType === 1) { // Node.ELEMENT_NODE\n                            const element = child as Element;\n                            const found = findFirstDescendantText(element);\n                            if (found) {\n                                return found;\n                            }\n                        }\n                    }\n                }\n                return undefined;\n            };\n\n            const processLink = async (link: Link) => {\n                // relative to publication root (package.opf / ReadiumWebPubManifest.json)\n                let href = link.HrefDecoded;\n                if (!href) {\n                    return;\n                }\n                if (isAudioOnly) {\n                    link.setHrefDecoded(href.replace(/\\.smil/, \".xhtml\"));\n                    return;\n                }\n                let fragment: string | undefined;\n                if (href.indexOf(\"#\") >= 0) {\n                    const arr = href.split(\"#\");\n                    href = arr[0].trim();\n                    fragment = arr[1].trim();\n                }\n                if (!href) {\n                    return;\n                }\n\n                let smilDoc = smilDocs[href];\n                if (!smilDoc) {\n                    const smilStr = await loadFileStrFromZipPath(href, href, zip);\n                    if (!smilStr) {\n                        debug(\"!loadFileStrFromZipPath\", smilStr);\n                        return;\n                    }\n                    smilDoc = new xmldom.DOMParser().parseFromString(smilStr, \"application/xml\");\n                    smilDocs[href] = smilDoc;\n                }\n\n                let targetEl = fragment ? smilDoc.getElementById(fragment) as Element : undefined;\n                if (!targetEl) {\n                    // const textElems = smilDoc.getElementsByTagName(\"text\");\n                    // if (textElems && textElems[0]) {\n                    //     targetEl = textElems[0];\n                    // }\n                    targetEl = findFirstDescendantText(smilDoc.documentElement);\n                }\n                if (!targetEl) {\n                    return;\n                }\n                if (targetEl.nodeName !== \"text\") {\n                    // const textElems = select(\"//text\", targetEl, true) as Element;\n                    // if (textElems) {\n                    //     targetEl = textElems;\n                    // }\n                    targetEl = findFirstDescendantText(targetEl);\n                }\n                if (!targetEl || targetEl.nodeName !== \"text\") {\n                    return;\n                }\n\n                const src = targetEl.getAttribute(\"src\");\n                if (!src) {\n                    return;\n                }\n                // TODO: path is relative to SMIL (not to publication root),\n                // and .xml file extension replacement is bit weak / brittle\n                // (but for most DAISY books, this is a reasonable expectation)\n                link.Href = src.replace(/\\.xml/, \".xhtml\");\n            };\n\n            const processLinks = async (links: Link[]) => {\n                for (const link of links) {\n                    await processLink(link);\n                    if (link.Children) {\n                        await processLinks(link.Children);\n                    }\n                }\n            };\n\n            if (publication.PageList) {\n                for (const link of publication.PageList) {\n                    await processLink(link);\n                }\n            }\n\n            if (publication.Landmarks) {\n                for (const link of publication.Landmarks) {\n                    await processLink(link);\n                }\n            }\n\n            if (publication.TOC) {\n                await processLinks(publication.TOC);\n            }\n\n            const jsonObj = TaJsonSerialize(publication);\n            const jsonStr = global.JSON.stringify(jsonObj, null, \"  \");\n            zipfile.addBuffer(Buffer.from(jsonStr), \"manifest.json\");\n        } catch (erreur) {\n            debug(erreur);\n        } finally {\n            timeoutId = setTimeout(() => {\n                timeoutId = undefined;\n                reject(\"YAZL zip took too long!? \" + outputZipPath);\n            }, 10000);\n            zipfile.end();\n        }\n    });\n};\n"]}